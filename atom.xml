<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>techbird blog</title>
  
  <subtitle>timeline of growth</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hashcode.cn/"/>
  <updated>2022-01-18T04:00:36.575Z</updated>
  <id>https://hashcode.cn/</id>
  
  <author>
    <name>techbird</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021 年度总结</title>
    <link href="https://hashcode.cn/2022/01/18/daily-2022-0118/"/>
    <id>https://hashcode.cn/2022/01/18/daily-2022-0118/</id>
    <published>2022-01-18T03:55:47.000Z</published>
    <updated>2022-01-18T04:00:36.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人只拥有此生此世是不够的，他还应该拥有诗意的人生。王小波</p></blockquote><h2 id="FLAGOF2022"><a href="#FLAGOF2022" class="headerlink" title="FLAGOF2022"></a>FLAGOF2022</h2><p>如果从flag的角度来总结即将过去的2021年，我会给自己打90分。90分代表对这一年自己努力的认可，扣掉的10分是有些事情如果更努力一点可以做的更好。希望自己不骄不躁，不骄是希望自己不盲目，不躁是勉励自己用平常心面对未来每一个选择。我一直对自己说要做一个长期主义者，当然主要是针对心态而言，不会去想急于求成的事情，努力做事，相信过程。</p><p>新的一年来了，就要让新的旗帜高高飘扬，2022年的flag如下：</p><p><img src="/images/daily/flagof2022.png" alt="FLAGOF2021"></p><p>读书24本需要平均每个月读两本书，再平均一下就是双周读一本，读书是为了用文字滋润自己的心灵不至于干涸，被世俗淹没；扇贝打卡350天是除了偶尔有一些着急的事情忘记打卡之外几乎不能间断；跑步2000公里相当于月跑量167km，跑步是为了有更健康的体魄去践行长期主义；英文仍然是与世界交流的窗口，能让自己保持读一手的资料感觉。不积跬步，无以至千里。以上三个flag是2022年我对自己的最低要求。</p><h2 id="2021我的阅读书单"><a href="#2021我的阅读书单" class="headerlink" title="2021我的阅读书单"></a>2021我的阅读书单</h2><ul><li>沉默的大多数 - 王小波</li><li>Mactalk跨越边界 - 迟建强</li><li>富爸爸，穷爸爸 - [美] 罗伯特 / 杨君、杨明</li><li>小狗钱钱 - [德] 舍费尔 / 王钟欣、余茜</li><li>Java核心技术卷1（第11版） - [美] 霍斯特曼 / 林琪、苏钰涵</li><li>MySQL技术内幕（第2版）- 姜承尧</li><li>Redis深度历险：核心原理与应用实践 - 钱文品</li><li>大型网站技术架构 - 李智慧</li><li>Spring实战（第5版）[美] 沃斯 / 张卫滨</li><li>Spring实战（第4版）[美] 沃斯 / 张卫滨</li><li>深度理解Java虚拟机（第3版） - 周志明</li><li>OKR工作法 - [美] 沃特克 / 明道团队</li><li>macOS效率手册 - 少数派</li><li>Java核心技术卷2 - [美] 霍斯特曼 / 陈昊鹏</li><li>SpringBoot实战 - [美] 沃斯 / 丁雪丰</li><li>局外人 - [法] 加缪 / 秦三澍</li><li>Java并发编程实战 - [美]Goetz / 童云兰</li><li>告别百年激进 - 温铁军</li><li>明朝那些事儿（1-3）- 当年明月</li></ul><p>2021年读了许多技术类书籍，对于技术的眼界和精进都有成长，但是没有完成每本书写一篇读书笔记的flag，算是遗憾。2021年写年终总结时我说当下需要刺刀见红的武器，当然还有一些大部头存货没有读完，所以2022年对于技术类书籍把存货读完，把已经完的时常重读即可。2022年开通微信读书年度会员168元，kindle unlimited每月12元，得到听书会员每月35元，仅电子书投资年接近千元，希望自己读耕不辍，读有所获。</p><h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>2022年在跑步这件事上坚持的还不错，除了三月份北京的连续雾霾天之外，月跑量都能100km+，10月返校后做到了月跑量200km+。虽然堆叠起来的只是数字，但能实实在在的感觉到自己的身体状况和精神头比以前有很大的改善。10月份返回学校后坚持健身三个月，每周四次，抗阻力量也有了一些进步。所谓身体是革命的本钱，新的一年自己要继续坚持。</p><h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><p>2021年理财上我觉得做的还不错的事情是在一月份开始定投了新能源，从国家战略碳中和，产业的上游（光伏和风电）到中游（储能）以及下游（新能源汽车）角度选定了标的，最好的时候接近做到了翻倍，一定程度上验证了个人的前途命运要和历史的进程结合在一起。当然也有做的不好的策略，比如让女朋友定投了中概互联，目前亏损10%+，但如果从长期持有的角度来看，我是相信互联网行业的前景的。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>4月份我从北京回到了学校，准备了春天的实习生面试事宜，顺利的拿到了阿里巴巴(杭州)和滴滴出行(北京)的实习，最终选择了滴滴。从2021年6月17日至2021年9月28日在滴滴实习100天。国庆之后返回学校。在实习期间和实习回到学校之后完整的参加了秋招，也顺利拿到了阿里菜鸟，B站，滴滴出行，小米，工行西研等offer。总的来说，2021年是努力和收获共同的季节。</p><h2 id="一些重要的小事"><a href="#一些重要的小事" class="headerlink" title="一些重要的小事"></a>一些重要的小事</h2><p>2021.01.14 - 2021年我27岁了。</p><p>2021.06.17 - 入职滴滴实习。</p><p>2021.11.15 - 签署毕业三方协议。</p><p><img src="/images/daily/endflagof2021.jpeg" alt="ENDFLAGOF2021"></p><h2 id="展望2022"><a href="#展望2022" class="headerlink" title="展望2022"></a>展望2022</h2><p>对于2022年，除了飘扬的flag要兑现，希望毕业顺利，以及保持身体健康。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;人只拥有此生此世是不够的，他还应该拥有诗意的人生。王小波&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;FLAGOF2022&quot;&gt;&lt;a href=&quot;#FLAGOF2022&quot; class=&quot;headerlink&quot; title=&quot;FLAGOF202
      
    
    </summary>
    
    
      <category term="Daily" scheme="https://hashcode.cn/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://hashcode.cn/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>SQL调优的流程</title>
    <link href="https://hashcode.cn/2021/04/28/sql-optimize-procedure/"/>
    <id>https://hashcode.cn/2021/04/28/sql-optimize-procedure/</id>
    <published>2021-04-28T02:01:47.000Z</published>
    <updated>2021-08-23T14:38:01.022Z</updated>
    
    <content type="html"><![CDATA[<p>SQL调优无论在实际工作中还是在面试过程中都是考查的重点，在文章中我将从慢查询分析和索引两个角度来介绍SQL调优的一点思路。</p><h2 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h2><p>SQL优化并不是漫无目的一条条去 <code>explain</code> SQL语句，需要具备针对性，所以我们只需要对执行时间超出我们预期的SQL进行针对的调整，那么慢查询分析日志就是帮我们快速定位超预期执行时间的SQL的一个有力工具。</p><h3 id="打开慢查询分析日志开关"><a href="#打开慢查询分析日志开关" class="headerlink" title="打开慢查询分析日志开关"></a>打开慢查询分析日志开关</h3><p>打开慢查询分析日志的开关的两种方式：1.修改配置文件，2.设置参数。我们下面使用设置参数的方式来演示：</p><ul><li><p>登入MySQL(略)</p></li><li><p>查看慢查询日志分析文件的配置信息：</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br></pre></td></tr></table></figure><ul><li>得到如下的配置信息：</li></ul><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">+---------------------+-------------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                           |</span><br><span class="line">+---------------------+-------------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                             |</span><br><span class="line">| slow_query_log_file | /usr/local/mysql/data/TechBird-Macbook-slow.log |</span><br><span class="line">+---------------------+-------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>把<code>slow_query_log</code> 的值 OFF 设置为 ON，即打开慢查询分析日志记录。记录的日志文件会保存在<code>slow_query_log_file</code> 的 Value 所指向的路径文件中，如果需要也可以对其进行修改。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log = <span class="string">'ON'</span>;</span><br></pre></td></tr></table></figure><h3 id="更改慢查询分析的默认时间"><a href="#更改慢查询分析的默认时间" class="headerlink" title="更改慢查询分析的默认时间"></a>更改慢查询分析的默认时间</h3><p>MySQL默认是的时间是 10 sec，显然时间太长了，我们可以修改这个参数为自己的心里预期时间：</p><p>查看默认时间配置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query%'</span>;</span><br></pre></td></tr></table></figure><p>得到如下的配置信息：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>修改默认的时间（单位：秒），一般在项目中可以设置为0.1秒，即100毫秒。为了演示方便下面将其设置为1秒：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>修改完所有参数之后要<code>quit;</code>重新登入数据库才能保证已设置的参数生效。</p><h3 id="构造一个慢的SQL测试语句"><a href="#构造一个慢的SQL测试语句" class="headerlink" title="构造一个慢的SQL测试语句"></a>构造一个慢的SQL测试语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sleep</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="查看慢查询分析的日志文件"><a href="#查看慢查询分析的日志文件" class="headerlink" title="查看慢查询分析的日志文件"></a>查看慢查询分析的日志文件</h3><p>温馨提示：在查看慢查询分析文件之前要<code>quit;</code> MySQL。</p><p>通过查看慢查询分析的日志文件，我们可以了解项目中哪些SQL超出了我们设置的预期执行时间，然后针对其进行优化：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;TechBird-Macbook-slow.log</span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Time: 2021-04-01T06:59:15.149853Z</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> User@Host: root[root] @ localhost [] Id:  419</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Query_time: 3.005275 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0</span></span><br><span class="line">SET timestamp=1617260355;</span><br><span class="line">select sleep(3);</span><br></pre></td></tr></table></figure><p>通过查看日志，可以准确的定位出是这条<code>select sleep(3);</code>执行超出了预期时间，从而利用下文所介绍的方法针对其进行优化。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>我们已经定位出了执行超出预期时间的SQL语句，一般来说可以使用<code>explain</code>工具对其进行分析定位问题，总结起来就是如下几点：</p><ol><li><p>理解 MySQL InnoDB 的索引原理</p></li><li><p>掌握 MySQL 执行计划的方法</p></li><li><p>掌握导致索引失效的常见情况</p></li><li><p>掌握实际工作中常用的建立高效索引的技巧（如前缀索引、建立覆盖索引等）</p></li></ol><p>在这之前我们需要先介绍一下索引相关的概念和知识。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>在实际应用中，InnoDB 是 MySQL 建表时默认的存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p><p>在创建表时，InnoDB 存储引擎默认使用表的主键作为主键索引，该主键索引就是<strong>聚簇索引</strong>（Clustered Index），如果表没有定义主键，InnoDB 就自己产生一个隐藏的 6 个字节的主键 ID 值作为主键索引，<strong>而创建的主键索引默认使用的是 B+Tree 索引</strong>。</p><ol><li><p>索引分类：<strong>普通索引</strong>、<strong>唯一索引</strong>、全文索引、空间索引</p><ul><li>在MySQL的官方文档中，create [option] index语法中，[option]就是用来修饰索引。</li><li><strong>缺省</strong>代表普通索引</li><li><strong>unique</strong>代表唯一索引</li><li><strong>fulltext</strong>代表全文索引，全文索引目前通常采用ElasticSearch来实现，而不是在数据库内部来做</li><li><strong>spatial</strong>代表空间索引，而空间索引在一些老的MySQL版本中是不支持的，一般用于存储一些地址坐标数据</li></ul></li><li><p>存储方式：<strong>B-Tree</strong>、Hash</p><ul><li>InnoDB支持B-Tree，不支持Hash</li><li>InnoDB 选择 B+Tree 当默认的索引数据结构</li><li>数据存储有序（最左前缀与此息息相关）</li><li>每个叶子节点到根的距离相同</li></ul></li><li><p>依赖列数：单列索引、组合索引</p></li><li><p>数据分布：<strong>聚簇索引</strong>、<strong>二级（辅助）索引</strong></p><ul><li>所谓聚簇索引就是指实际的数据行直接存到了叶子节点当中，而主键索引是聚簇索引的一个通常的形式。</li><li>通过主键查询数据，不需要回表，直接就可以得到数据行，效率较高。</li><li>非聚簇（主键）索引（辅助索引），叶子节点保存的不是最终的数据行，而只是一个主键值，需要通过主键值再去主键（聚簇）索引里查询最终叶子节点的数据行。因此需要走两次索引，是索引的索引，所以称为二级索引或辅助索引。这个过程叫<strong>回表</strong>。</li></ul></li><li><p>回表情况：<strong>覆盖索引</strong></p><ul><li><p>当一个索引包含（覆盖）了需要查询的字段值时，称其为覆盖索引</p></li><li><p>只有select、where中出现的列被索引覆盖的情况才是覆盖索引</p></li><li><p>此时如果使用 explain 分析可以看到 Extra 的值为Using index</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">colums: a b c d e</span><br><span class="line">index(a,b,c)</span><br><span class="line"><span class="keyword">select</span> a,b,c <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="string">""</span> <span class="keyword">and</span> b=<span class="string">""</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="最左前缀-Leftmost-Prefixing"><a href="#最左前缀-Leftmost-Prefixing" class="headerlink" title="最左前缀(Leftmost Prefixing)"></a>最左前缀(Leftmost Prefixing)</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">table T,index(a,b,c)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全值匹配</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="string">''</span> <span class="keyword">and</span> b=<span class="string">''</span> <span class="keyword">and</span> c=<span class="string">''</span>; <span class="comment">-- YES</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> c=<span class="string">''</span> <span class="keyword">and</span> b=<span class="string">''</span> <span class="keyword">and</span> a=<span class="string">''</span>; <span class="comment">-- YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配左前缀</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="string">''</span>; <span class="comment">-- YES</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> b=<span class="string">''</span>; <span class="comment">-- NO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配列前缀</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">'x%'</span>; <span class="comment">-- YES</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">'%x'</span>; <span class="comment">-- NO</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> b <span class="keyword">like</span> <span class="string">'x%'</span>; <span class="comment">-- NO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配范围值</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">between</span> <span class="string">''</span> <span class="keyword">and</span> <span class="string">''</span>; <span class="comment">-- YES</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> b <span class="keyword">between</span> <span class="string">''</span> <span class="keyword">and</span> <span class="string">''</span>; <span class="comment">-- NO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全值匹配 + 范围值匹配</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> a=<span class="string">''</span> <span class="keyword">and</span> b <span class="keyword">between</span> <span class="string">''</span> <span class="keyword">and</span> <span class="string">''</span>; <span class="comment">-- YES</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> b=<span class="string">''</span> <span class="keyword">and</span> c <span class="keyword">between</span> <span class="string">''</span> <span class="keyword">and</span> <span class="string">''</span>; <span class="comment">-- NO</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">between</span> <span class="string">''</span> <span class="keyword">and</span> <span class="string">''</span> <span class="keyword">and</span> b=<span class="string">''</span>; <span class="comment">-- NO</span></span><br></pre></td></tr></table></figure><h3 id="执行计划-explain"><a href="#执行计划-explain" class="headerlink" title="执行计划(explain)"></a>执行计划(explain)</h3><p>了解完上面的概念之后，我们来介绍一下在实际工作中如何查看索引的执行计划。</p><p>我这里有一张存储用户信息的演示表 tab_user：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`tab_user`</span></span><br><span class="line">(</span><br><span class="line">   <span class="string">`uid`</span>                 <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">   <span class="string">`username`</span>            <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">   <span class="string">`password`</span>            <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">   <span class="string">`name`</span>                <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">null</span>,   </span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`uid`</span>) <span class="keyword">using</span> btree,</span><br><span class="line">  <span class="keyword">key</span> <span class="string">'index_name'</span> (<span class="string">'name'</span>),</span><br><span class="line">    <span class="keyword">key</span> <span class="string">'index_uid_name'</span> (<span class="string">'uid'</span>,<span class="string">'name'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表中包含了主键索引、name 字段上的普通索引，以及 uid 和 name 两个字段的联合索引。现在我们来看一条简单查询语句的执行计划：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> uid,<span class="keyword">name</span> <span class="keyword">from</span> tab_user <span class="keyword">where</span> uid=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/tech/image-20210401173711705.png" alt="explain-sql"></p><p>对于执行计划，参数有 possible_keys 字段表示可能用到的索引，key 字段表示实际用的索引，key_len 表示索引的长度，rows 表示扫描的数据行数，filtered表示覆盖率%。Extra表示额外的信息说明。</p><p><strong>这其中需要重点关注type字段</strong>，表示数据扫描类型，也就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为（考虑到查询效率问题，全表扫描和全索引扫描要尽量避免）：</p><ul><li><p>ALL（全表扫描）；</p></li><li><p>index（全索引扫描）；</p></li><li><p>range（索引范围扫描）；</p></li><li><p>ref（非唯一索引扫描）；</p></li><li><p>eq_ref（唯一索引扫描）；</p></li><li><p>const（结果只有一条的主键或唯一索引扫描）。</p></li></ul><p>总的来说，执行计划是研发工程师分析索引详情必会的技能（很多大厂公司招聘 JD 上写着“SQL 语句调优” ），所以你在面试时也要知道执行计划核心参数的含义，如 type。在回答时，也要以重点参数为切入点，再扩展到其他参数，然后再说自己是怎么做 SQL 优化工作的（讲个故事）。</p><h3 id="索引失效的常见情况"><a href="#索引失效的常见情况" class="headerlink" title="索引失效的常见情况"></a>索引失效的常见情况</h3><p>在工作中，我们经常会碰到 SQL 语句不适用已有索引的情况，来看一个索引失效的例子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tab_user <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%z'</span></span><br></pre></td></tr></table></figure><p>这条带有 like 查询的 SQL 语句，没有用到 tab_user 表中的 index_name 索引。</p><p><img src="/images/tech/image-20210402080934143.png" alt="explain-sql2"></p><p>我们结合普通索引的B+Tree结构来分析一下索引失效的原因：当MySQL优化器根据name like ‘%z’这个条件，到索引index_name的B+Tree结构上去查询评估时，发现当前节点的左右子节点的值都有可能符合’%z’这个条件，于是优化器判定当前索引需要扫描整个索引，而且还要回表查询，不如直接全表扫描。</p><p>当然还有其他类似的索引失效的情况：</p><ol><li>索引列上做了表达式计算、函数、隐式类型转换操作，这些情况下索引失效是因为查询过程需要扫描整个索引并回表，代价高于直接全表扫描；</li><li>like匹配使用了左模糊查询（’%abc’）或左右模糊查询（’%abc%’）；</li><li>字符串不加引号导致隐式类型转换；</li><li>被使用的索引字段不是联合索引的最左字段</li></ol><p>总结：如果MySQL查询优化器预估走索引的代价比全表扫描的代价还要大，则不走对应的索引，直接扫描全表。如果走索引比全表扫描代价小，则使用索引。</p><h3 id="常见优化索引的方法"><a href="#常见优化索引的方法" class="headerlink" title="常见优化索引的方法"></a>常见优化索引的方法</h3><ul><li><p>前缀索引优化</p><ul><li><p>前缀索引就是用某个字段中，字符串的前几个字符建立索引；使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p></li><li><p>但是前缀索引有一定的局限性，例如 <strong>order by 就无法使用前缀索引</strong>，无法把前缀索引用作覆盖索引。</p></li></ul></li><li><p>覆盖索引优化</p><ul><li><p><strong>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+ Tree 的叶子节点上都能找得到的那些索引，从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得。</strong></p></li><li><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个组合索引，即商品ID、名称、价格作为一个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。所以，使用覆盖索引的好处很明显，即不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。</p></li></ul></li><li><p>联合索引</p><ul><li><strong>联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。</strong></li><li>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。</li><li><img src="/images/tech/image-20210401174931790.png" alt="distinct"></li><li>区分度就是某个字段 column 不同值的个数除以表的总行数，比如性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 uuid 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/images/tech/image-20210401175722407.png" alt="summary"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s/xaJg28qXCAC4XR2mTm4xUg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xaJg28qXCAC4XR2mTm4xUg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQL调优无论在实际工作中还是在面试过程中都是考查的重点，在文章中我将从慢查询分析和索引两个角度来介绍SQL调优的一点思路。&lt;/p&gt;
&lt;h2 id=&quot;慢查询分析&quot;&gt;&lt;a href=&quot;#慢查询分析&quot; class=&quot;headerlink&quot; title=&quot;慢查询分析&quot;&gt;&lt;/a&gt;慢
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hashcode.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://hashcode.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java Lambda 表达式详解</title>
    <link href="https://hashcode.cn/2021/02/24/java-lambda/"/>
    <id>https://hashcode.cn/2021/02/24/java-lambda/</id>
    <published>2021-02-24T11:01:47.000Z</published>
    <updated>2021-08-23T14:38:01.014Z</updated>
    
    <content type="html"><![CDATA[<p>Lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>表达式形式：参数，箭头(-&gt;)，以及一个表达式。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(String first, String second) -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure><p>如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在<code>{}</code>中，并包含显示的<code>return</code>语句。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（String first, String second）-&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &gt;= <span class="number">0</span>; i—) System.out.println(i);&#125;</span><br></pre></td></tr></table></figure><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure><p>在这里，编译器可以推导出first和second必然是字符串，因为这个lambda表达式将赋给一个字符串比较器。</p><p>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActionListener listener = event -&gt; System.out.println(“test”);</span><br></pre></td></tr></table></figure><p>无须指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first, String second) -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure><p>可以在需要int类型结果的上下文中使用。</p><p>注释：如果lambda表达式只在某些分支返回一个值，而另外一些分支不返回值，这是不合法的。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span> x) -&gt; &#123; <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; &#125;<span class="comment">//不合法</span></span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口成为函数式接口（functional interface）。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(words,(first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure><p>在底层，Arrays.sort 方法会接受实现了Comparator<String>的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。</p><p>注释：最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lamda表达式可以传递到函数式接口。实际上在Java中，对lambda表达式所能做的也只是转换为函数式接口，Java设计者没有为Java语言增加函数类型（在其他程序设计语言中，可以声明函数类型的变量）。不能把lambda表达式赋值给类型为Object的变量，因为Object不是函数式接口。</p><p><code>java.util.function</code> 包中定义了很多非常通用的函数式接口。例如：</p><p><code>Predicate</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//additional default and static methods</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList类中有一个<code>removeIf</code>方法，它的参数就是一个<code>Predicate</code>。这个接口专门用来传递lambda表达式。例如，下面的语句将从一个数组列表中删除所有的null值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.removeIf(e -&gt; e == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><code>Supplier</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>供应者（supplier）没有参数，调用时会生成一个<code>T</code>类型的值。供应者用于实现<code>懒</code>计算：例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate hireDay = Objects.requireNonNullOrElse(day, <span class="keyword">new</span> LocalDate(<span class="number">1970</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>这不是最优的，我们与day很少为null，所以希望只在必要时才构造默认的LocalDate，通过使用供应者，我们就能延迟这个计算：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate hireDay = Objects.requireNonNullOrElseGet(day, () -&gt; <span class="keyword">new</span> LocalDate(<span class="number">1970</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><code>requireNonNullOrElseGet</code> 方法只在需要值时才调用供应者。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>有时，lambda表达式涉及一个方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br></pre></td></tr></table></figure><p>但是，如果直接把<code>println</code>方法传递到Timer构造器就更好了。具体做法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer(<span class="number">1000</span>,System.out::println);</span><br></pre></td></tr></table></figure><p>表达式<code>System.out::println</code>是一个方法引用（method reference），他只是编译器生成一个函数式接口的实例，覆盖整个接口的抽象方法来调用给定的方法。在这个例子中，会生成一个 ActionListener，它的 actionPerformed(ActionEvent e) 方法要调用 System.out.println(e)。</p><p>注释：类似于lambda表达式，方法引用也不是一个对象。不过，为一个类型为函数式接口的变量赋值时会生成一个对象。</p><p>再来看一个例子，假设想对字符串进行排序，而不考虑字母的大小写，可以传递以下方法表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strings,String::compareToIgnoreCase)</span><br></pre></td></tr></table></figure><p>小结：要用<code>::</code>运算符分割方法与对象或者类名。主要有3种情况：</p><ol><li>object::instanceMethod</li><li>Class::instanceMethod</li><li>Class::staticMethod</li></ol><p>在第1种情况下，方法引用等价于向方法传递参数的lambda表达式。对于<code>System.out::println</code>，对象是 System.out，所以方法表达式等价于 <code>x -&gt; System.out.println(x)</code>。</p><p>对于第2种情况，第1个参数会成为方法的隐式参数。例如，<code>String::compareToIgnoreCase</code></p><p>等同于<code>(x, y) -&gt; x.compareToIgnoreCase(y)</code>。</p><p>在第3种情况下，所有参数都会传递到静态方法：<code>Math::pow</code>等价于<code>(x, y) -&gt; Math.pow(x, y)</code></p><p><code>注</code>：只有当lambda表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。考虑以下表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s -&gt; s.length == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里有一个方法调用。但是还是有一个比较，所以这里不能使用方法引用。</p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><p>构造器引用与方法引用很类似，只不过方法名为new。例如，<code>Person::new</code> 是 Person 构造器的一个引用。</p><p>可以用数组类型简历构造器引用。例如，<code>int[]::new</code>是一个构造器引用，他有一个参数：即数组的长度。这等价于lambda表达式<code>x -&gt; new int[x]</code>。</p><p>Java有一个限制，无法构造泛型类型<code>T</code>的数组。但是利用数组构造器可以克服这个限制，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>toArray方法调用这个构造器来得到一个有正确类型的数组。然后填充并返回这个数组。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式有3个部分：</p><ol><li>一个代码块；</li><li>参数；</li><li>自由变量的值，这里指非参数而且不在代码中定义的变量</li></ol><p>lambda表达式中访问外围方法或者类中的变量。lambda表达式中捕获的变量必须实际上是事实最终变量（effectively final），事实最终变量是指，这个变量初始化之后就不会再为它赋新值。在下面例子中，text总是指示同一个String对象，所以捕获这个变量是合法的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">  ActionListener listener = event -&gt; &#123;</span><br><span class="line">   System.out.println(text);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lambda表达式中，只能引用值不会改变的变量（因为，如果在lambda表达式中更改变量，并发执行多个动作是就会不安全），下面这种做法是不合法的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">  ActionListener listener = event -&gt; &#123;</span><br><span class="line">     start--; <span class="comment">//ERROR：Can’t mutate captured variable</span></span><br><span class="line">     System.out.println(start);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在lambda表达式中引用一个变量，而这个变量可能在外部改变，这也是不合法的。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(String text, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)&#123;</span><br><span class="line">     ActionListener listener = event -&gt; &#123;   </span><br><span class="line">       <span class="comment">//i的值会改变，因此不能捕获i</span></span><br><span class="line">       System.out.println(String.valueOf(i) + text);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>lambda表达式的体与嵌套块有相同的作用域。所以这里同样适用命名冲突和遮蔽的有关规则。在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</li><li>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ActionListener listener = event -&gt; &#123;  </span><br><span class="line">      System.out.println(<span class="keyword">this</span>.toString());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式<code>this.toString()</code>会调用Application对象的toString方法，而不是ActionListener实例的方法。</p><h2 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h2><p>如何编写方法处理lambda表达式?，使用lambda表达式的重点是延迟执行</p><ol><li>需要选择一个合适的函数式接口</li><li>可以选择自定义函数式接口，建议使用<code>@FunctionalInterface</code>注解标记这个接口，这样如果无意中增加了另一个抽象方法，编译器就会产生一个错误消息</li></ol><h2 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈Comparator</h2><p>Comparator接口包含很多方便的静态方法来创建比较器，这些方法可以用于lambda表达式或方法引用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Core Java Volume I — Fundamentals (Eleventh Edition)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;表达式形式：参数，箭头(-&amp;gt;)，以及一个表达式。例
      
    
    </summary>
    
    
      <category term="Java" scheme="https://hashcode.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://hashcode.cn/tags/Java/"/>
    
      <category term="lambda" scheme="https://hashcode.cn/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>财商启蒙 - 读《富爸爸穷爸爸》</title>
    <link href="https://hashcode.cn/2021/01/31/read-fbbqbb/"/>
    <id>https://hashcode.cn/2021/01/31/read-fbbqbb/</id>
    <published>2021-01-31T11:55:47.000Z</published>
    <updated>2021-08-23T14:38:01.020Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/read/read_fbbqbb.jpg" alt="富爸爸穷爸爸"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这是一本被认为是财商启蒙的畅销书，作者罗伯特·清崎是一位日裔美国人。对于其书中所陈述的自己的成功，在网络上有一定的争议；其中具有代表性的是，在2012年有新闻报道《富爸爸穷爸爸》的作者拥有的一家公司申请破产。但之后又被澄清说只是公司破产而并非个人破产。无论作者怎样，读完这本书之后，我觉得书中还是有几个观点值得思考和学习。</p><h3 id="财商"><a href="#财商" class="headerlink" title="财商"></a>财商</h3><p>作者认为人们一定要学习财务知识，要真正认识到资产和负债的区别，用正确的态度来对待金钱。展开来讲就是从长远来看，重要的不是赚了多少钱，而是有多少钱留下；而资产是以最低限度的劳动把钱放进我们口袋的东西，负债是把钱从我们口袋里拿走的东西；钱的作用是解决问题，解决问题本身很重要，而工作只是面对长期问题的一种暂时的解决办法。建议人们要关注自己的事业，把事业的重心放到资产项而不是收入项。那么第一笔资产的积累怎么获得？针对成年人切实可行的办法就是，把支出保持在低水平并勤劳的工作会有助于打下稳固的资产基础。</p><ul><li><p>什么是财商（财务知识）?</p><ul><li>会计（财务知识，也就是解读数字的能力以及评估一项生意的优势和劣势）</li><li>投资（钱生钱的科学和策略）</li><li>了解市场（供给与需求的科学以及市场条件）</li><li>法律（减税优惠和在诉讼中获得保护）</li></ul></li><li><p>资产和负债（这张图片很清晰的表达了作者不断提到的思想）</p><p><img src="/images/read/read_fbbqbb_01.png" alt=""></p></li></ul><h3 id="首先支付自己"><a href="#首先支付自己" class="headerlink" title="首先支付自己"></a>首先支付自己</h3><p>「首先支付自己」就是首先不能陷入债务之中。遵循一下两个法则：</p><p>1．不要让自己背上数额过大的债务包袱。保持低支出。首先建立资产项，然后再用资产项购买大房子或豪车。</p><p>2．当你资金短缺时，让压力去发挥作用，不要动用你的储蓄或投资。利用压力激发你的理财天赋，想出新的赚钱方法，然后支付你的账单。这样不但能让你赚到钱，还能提高你的财商。</p><h3 id="利用金钱的力量"><a href="#利用金钱的力量" class="headerlink" title="利用金钱的力量"></a>利用金钱的力量</h3><p>作者认为在积累财富的过程中，最困难的事情莫过于坚持自己的选择而不盲目从众。因为在竞争激烈的市场上，群体往往会反应迟钝，成为被“宰割”的对象。真正的投资者在市场上涨和下跌时都能赚钱。而实现财务自由和获得巨大财富的关键取决于一个人将劳动性收入转化成被动收入或投资组合收入的能力。正如美国最富有的投资者沃伦·巴菲特说的「风险来自于你不知道自己在做什么」，如果非常清楚自己在做的事情，那么投资就不具有风险，这是投资的常识。</p><h3 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h3><p>我从作者认为的唤醒投资天赋的10个步骤，选出来几条目前自己认可的观点。</p><ul><li><p>寻找让自己致富的精神力量</p></li><li><p>首先投资学习（多听，多学习。以长远的眼光来看待财富，不要存有一夜暴富的念头。在投资股票或房地产之前，请先投资你最重要的资产——头脑。）</p></li><li><p>不要听贫穷的人或胆小的人话</p></li><li><p>辩证双刃的听取两极的言论</p></li><li><p>养成自律的消费习惯（能否自律是将富人、穷人和中产阶级区分开的首要因素）</p></li><li><p>压力就是动力（不要随便动用储蓄）</p></li><li><p>学会选择并利用专业人士（好建议的力量）</p></li><li><p>学会和职位比自己高的人一起工作（许多中层管理人员一直停留在中层，就是因为他们只知道如何与职位低于自己的人一起工作，却不善于和比自己职位高的人一起工作。）</p></li><li><p>慎重的选择朋友（每个人的成功和失败都有其可取之处）</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上天赐予我们每个人两样伟大的礼物：思想和时间。你可以运用这两件礼物去做你愿意做的事情。这是一个可以转变如何正确积累财富的启蒙好书，推荐给大家。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/read/read_fbbqbb.jpg&quot; alt=&quot;富爸爸穷爸爸&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;这是一本被认为是财
      
    
    </summary>
    
    
      <category term="Readed" scheme="https://hashcode.cn/categories/Readed/"/>
    
    
      <category term="Readed" scheme="https://hashcode.cn/tags/Readed/"/>
    
  </entry>
  
  <entry>
    <title>2020 年度总结</title>
    <link href="https://hashcode.cn/2021/01/02/daily-2021-0103/"/>
    <id>https://hashcode.cn/2021/01/02/daily-2021-0103/</id>
    <published>2021-01-02T06:44:47.000Z</published>
    <updated>2022-01-18T03:39:33.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FLAGOF2021"><a href="#FLAGOF2021" class="headerlink" title="FLAGOF2021"></a>FLAGOF2021</h2><blockquote><p>回忆的动人之处就在于可以重新选择，可以将那些毫无关系的往事重新组合起来，从而获得了全新的过去。余华</p></blockquote><p>回顾2020年的立下的 flag 觉得完成度还是非常高，比如跑步double了，英语打卡几乎全年满卡(2020/01/25开始)，论文虽然经历了两次拒稿，但还是写出来了，剩下的只需要修改完善即可。那么，新的一年到来的时候就需要插上新的 flag，无论去年的完成了多少。2020年的 flag 带来了许多收获，明白了即使微小的坚持可能会带来意想不到的结果。比如 CET-6 不经意的就考过了。2020年花了比较多的精力在算法上，所以决定2021年给自己添加一个 LeetCode of Flag 并将它保持下去 。</p><p><img src="/images/daily/flagof2021.png" alt="FLAGOF2021"></p><h2 id="2020我的阅读书单"><a href="#2020我的阅读书单" class="headerlink" title="2020我的阅读书单"></a>2020我的阅读书单</h2><ul><li>芳华 - 严歌苓</li><li>如何攻读博士学位 - 冯长根</li><li>白鹿原 - 陈忠实</li><li>MySQL 必知必会 - [英] Ben Forta / 刘晓霞、钟鸣</li><li>邓小平时代 - [美] 傅高义 / 冯克利</li><li>一个人的村庄 - 刘亮程</li><li>当我跑步时我谈些什么 - [日] 村上春树 / 施小炜 </li><li>在细雨中呼喊 - 余华</li><li>黄金时代 - 王小波</li></ul><p>豆瓣给我的 2020 的读书总结是：「这一年中有6个月与书籍为伴，喜欢在午后阅读，通常喜欢读文学类。」相比 2019 年，今年留在阅读上的时间非常少，大多都是疫情在家隔离期间读完，返校后便没有什么进展了。于是，2020年立下的读书 flag 惨遭打脸。既然立多了，那2021年就少一些，12本，相当于每月读一本书；但需要把读书的口味暂时性的迁移到「理财」和「技术」类。因为作为一个年轻的社会主义战士，当下我更需要这些可以刺刀见红的武器。白岩松有句话说：「那些以前读过的书，虽然很多时候记不起书里的内容，可是它并不会白读，它已经成为了你血液中的一部分，时时刻刻影响你的三观。」  我认为一定程度上，这只是一句鸡汤，实操性的书是需要记录和实践的。比如投资和编程。所以，2021年把自己的阅读量定的少一些，但每一本书都写一篇读书笔记。</p><h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><blockquote><p>“疼痛无法避免，磨难却可以选择”，每当我长跑的时候，脑海里就反复出现这句话。村上春树</p></blockquote><p>疫情在家隔离期间体重飙升至80kg，于是从5月18日返校开始，重新开始跑步。2020年是跑量最多的一年（1003km）。其中跑了2个半马，参加了太原线下半程马拉松，最好的成绩进了2小时。于是体重回到了70kg。起起伏伏的一年就算过去了。</p><p><img src="/images/daily/taiyuanmarathon2020.JPG" alt="taiyuan-marathon-2020"></p><h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><p>作为一名在读学生，并没有什么钱。但是人一定不是因为有了钱才开始理财的，所以理财的种子需要提早播种，有人说学理财最快的方式就是拿一些钱投进去，亏钱了，慢慢就学会了。于是今年我开始买基金，了解了什么是定投。给自己规划了一些必看的理财书籍，希望2021年投资方面能够在知识和实践上都有所获，并写在此处记录。</p><h2 id="一些重要的小事"><a href="#一些重要的小事" class="headerlink" title="一些重要的小事"></a>一些重要的小事</h2><p>2020.01.14 - 2020年我26岁了。</p><p>2020.06.22 - 灯火阑珊，找到了我的soulmate</p><p>2020.09.10 - 拿到了驾照</p><p>2020.10.01 - 带她回家见了爸妈</p><p>2020.11.04 - 六级顺利通过，签了实习离校协议</p><ul><li>扇贝打卡天数-体重-每月跑量</li></ul><p><img src="/images/daily/endflagof2020.JPG" alt="扇贝打卡天数-体重-每月跑量"></p><h2 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h2><p>对于2021年，除了飘扬的flag要兑现，还希望能获得一份满意的实习经历、能够在秋招中有满意的斩获、小论文能够顺利投中、完成投资和储蓄计划；以及保持身体健康。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FLAGOF2021&quot;&gt;&lt;a href=&quot;#FLAGOF2021&quot; class=&quot;headerlink&quot; title=&quot;FLAGOF2021&quot;&gt;&lt;/a&gt;FLAGOF2021&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;回忆的动人之处就在于可以重新选择，可以将那些毫无关
      
    
    </summary>
    
    
      <category term="Daily" scheme="https://hashcode.cn/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://hashcode.cn/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>Linux Common Sense</title>
    <link href="https://hashcode.cn/2020/11/21/linux-common-sense/"/>
    <id>https://hashcode.cn/2020/11/21/linux-common-sense/</id>
    <published>2020-11-21T14:51:51.000Z</published>
    <updated>2021-08-23T14:38:01.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-的发展史"><a href="#linux-的发展史" class="headerlink" title="linux 的发展史"></a>linux 的发展史</h1><ul><li>Unix</li><li>Minix</li><li>Linux</li></ul><h1 id="linux-的版本"><a href="#linux-的版本" class="headerlink" title="linux 的版本"></a>linux 的版本</h1><ul><li>内核版本</li><li>发行版本：redhat、ubuntu、centos</li></ul><h1 id="linux-下常用的目录结构"><a href="#linux-下常用的目录结构" class="headerlink" title="linux 下常用的目录结构"></a>linux 下常用的目录结构</h1><ul><li><code>/</code>：根目录</li><li><code>~</code>：用户的家目录</li><li><code>.</code>：当前目录</li><li><code>/home</code> ：系统默认的用户home目录，存放普通用户相关文件</li><li><code>/root</code>：管理员的home目录，存放root用户相关文件</li><li><code>/bin</code>：存放linux常用命令的目录，如ls、vi、cat等</li><li><code>/sbin</code>：需要一定权限才可以使用该目录下的命令</li><li><code>/etc</code>：存放系统配置相关文件</li><li><code>/tmp</code>：存放用户或正在执行的程序临时存放文件的目录</li><li><code>/usr</code>：安装一个软件的默认目录，相当于windows下的program files</li><li><code>/var</code>：存放经常变化的文件，如网络连接的sock文件、日志等</li><li><code>/boot</code>：存放引导系统启动的相关文件</li><li><code>/proc</code>：这是虚拟目录，不占磁盘空间。是系统内存的映射，访问这个目录来获取系统相关信息</li><li><code>/mnt</code>：默认挂在光驱和软驱的目录</li><li><code>/dev</code>：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备</li><li><code>/srv</code>：service的缩写。该目录提供一些服务启动之后需要读取的数据</li><li><code>/sys</code>：linux 2.6内核之后一个变化，该目录下安装了一个2.6之后出现的新文件系统</li><li><code>/del</code>：类似于windows的设备管理器，把所有的硬件以文件的形式存储</li><li><code>/media</code>：用于临时挂载被的文件系统</li><li><code>/opt</code>：用于存放主机额外的软件，如oracle数据库就可以放在该目录下</li></ul><h1 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command [-opitons] [parameter]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>command</code>：命令名</li><li><code>[-option]</code>：选项，可用来对命令进行控制和细化，也可省略</li><li><code>[parameter]</code>：传递给命令的参数，可以是0个、1个或多个</li><li><code>[]</code>：代表可选</li></ul><h1 id="查阅命令的帮助信息"><a href="#查阅命令的帮助信息" class="headerlink" title="查阅命令的帮助信息"></a>查阅命令的帮助信息</h1><ul><li><code>command --help</code>：显示<code>command</code>命令的帮助信息</li><li><code>man command</code>：查阅<code>command</code>命令的使用手册<ul><li>使用<code>man</code>命令时的操作键：</li><li><code>space</code>，显示下一页</li><li><code>enter</code>，一次滚动手册页的一行</li><li><code>b</code>，回滚一页</li><li><code>f</code>，前滚一屏</li><li><code>q</code>，退出</li><li><code>/word</code>，搜索word字符串</li></ul></li></ul><h1 id="常见的linux命令"><a href="#常见的linux命令" class="headerlink" title="常见的linux命令"></a>常见的linux命令</h1><ul><li><p><code>ssh username@ip -p port</code>：链接远程服务器命令</p></li><li><p><code>exit</code>：退出登录</p></li><li><p><code>ls</code>：查看当前文件下的内容</p><ul><li><code>ll</code>：<code>ls -l</code>的简写</li><li><code>-a</code>：a=all，显示指定文件下所有子目录与文件，包括隐藏文件</li><li><code>-l</code>：l=list，以列表形式显示详细信息</li><li><code>-h</code>：h=humanity，配合<code>-l</code>以人性化的方式展示文件大小</li></ul></li><li><p><code>pwd</code>：查看当前所在文件夹</p></li><li><p><code>touch [文件名]</code>：新建文件</p><ul><li><code>touch file1 file2 ...</code>：创建多个文件</li></ul></li><li><p><code>mkdir [目录名]</code>：创建目录</p><ul><li><code>mkdir -p dir1/dir2/dir3</code>：递归创建目录</li></ul></li><li><p><code>rm [文件名]</code>：删除指定的文件名</p><ul><li><code>rmdir</code>/<code>rm -r</code>：删除文件夹</li><li><code>-r</code>：recursion，表示删除目录</li><li><code>-f</code>：force，强制</li><li><code>-i</code>：interactive，以交互的方式删除</li></ul></li><li><p><code>mv</code>：移动、重命名</p><ul><li><code>mv 1.txt 2.txt</code></li><li><code>-f</code>：强制移动，如有覆盖会给出提示</li><li><code>-i</code>：交互式操作，如覆盖目标之前提示</li><li><code>-v</code>：展示移动进度</li></ul></li><li><p><code>cp</code>：文件或者目录的复制</p><ul><li><code>cp 1.txt 2.txt</code></li><li><code>-a</code>：保持文件原有属性</li><li><code>-f</code>：覆盖已经存在的目标文件而不提示</li><li><code>-i</code>：交互式复制，在覆盖目标文件之前提示</li><li><code>-r</code>：目标文件必须为目录。会拷贝该目录下所有子目录和文件</li><li><code>-v</code>：展示拷贝进度</li></ul></li><li><p><code>find</code>：查找指定目录下的文件</p><ul><li>一般格式：<code>find 路径 -name 文件名</code></li><li><code>find . -name test.sh</code>：查找当前目录下名为test.sh的文件</li><li><code>find . name &#39;*.sh&#39;</code>：查找当前目录下所有以.sh后缀结尾的文件</li></ul></li><li><p><code>grep</code>：文本搜索</p><ul><li>一般格式：<code>grep [-options] &#39;搜索内容&#39; 文件名</code></li><li>eg：<code>grep &#39;a&#39; 1.txt</code></li><li><code>-v</code>：显示不包含匹配文本的所有行，即取反</li><li><code>-n</code>：显示匹配行及行号</li><li><code>-i</code>：忽略大小写</li><li>搜索内容支持正则表达式<ul><li><code>^a</code>：表示以a开头。eg：<code>grep -n &#39;^a&#39; a.txt</code></li><li><code>b$</code>：表示以b结尾。eg：<code>grep -n &#39;b$&#39; a.txt</code></li><li>[a-z]：范围中的一个。eg：<code>grep -n [a-z][a-z][a-z].txt b.txt</code></li></ul></li></ul></li><li><p><code>tar</code>：归档管理</p><ul><li>一般格式：<code>tar [参数] 打包文件名 文件</code></li><li>打包 ：<code>tar cvf 包名.tar 文件名</code></li><li>解包 ：<code>tar xvf 包名.tar -C 路径</code></li><li><code>-c</code>：生成档案文件，创建打包文件</li><li><code>-v</code>：列出归档解档的详细过程，显示进度</li><li><code>-f</code>：指定档案文件名称</li><li><code>-t</code>：列出档案中包含的文件</li><li><code>-x</code>：解开档案文件</li><li><code>-z</code> ：归档压缩。调用gzip的压缩功能，先打包后压缩。默认后缀名为 file.tar.gz<ul><li>打包：<code>tar cvzf 压缩包包名 文件1 文件2 ...</code></li><li>解包：<code>tar zxvf 包名 -C 路径</code></li></ul></li><li>注意：<code>tar</code> 命令<code>[参数]</code>前面可以使用<code>-</code>，也可以省略</li></ul></li><li><p><code>gzip</code>：文件压缩解压，用gzip压缩tar打包后的文件扩展名一般用<code>xxx.tar.gz</code></p><ul><li><code>gzip [选项] 被压缩文件</code></li><li><code>-d</code>：解压</li><li><code>-r</code>：压缩所有子目录</li></ul></li><li><p><code>chmod</code>：修改文件权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个文件创建完成后，默认会有三个组：属主，属组，其他。每个组默认会有三个权限</span><br><span class="line">属主owner，属组group，其他other</span><br><span class="line">rwx，       rwx，     rwx</span><br></pre></td></tr></table></figure><ul><li>字母法：<code>chmod u/g/o/a +/-/= rwx filename</code><ul><li><code>u</code>：user，表示文件的所有者</li><li><code>g</code>：group，用户组</li><li><code>o</code>：other，其他</li><li><code>a</code>：all，以上三者皆是</li><li><code>+</code>：增加权限</li><li><code>-</code>：撤销权限</li><li><code>=</code>：设定权限</li><li><code>r</code>：read，读取权限</li><li><code>w</code>：write，写入权限</li><li><code>x</code>：excute，执行权限</li></ul></li><li>数字法：<code>chmod 751 filename</code><ul><li><code>r</code>：读取权限，数字代号为<code>4</code></li><li><code>w</code>：写入权限，数字代号为<code>2</code></li><li><code>x</code>：执行权限，数字代号为<code>1</code></li><li><code>-</code>：不具有任何权限，数字代号为<code>0</code></li></ul></li><li>eg：<code>chmod u=rwx,g=rx,o=r filename</code> 等同于 <code>chmod u=7,g=6,o=1 filename</code></li><li><code>-R</code>：递归所有目录加上相同权限，如<code>chmod 777 test/ -R</code> 递归test目录下所有文件加777权限</li></ul></li><li><p><code>who</code>：用于查看当前所有登录系统的用户信息</p><ul><li><code>-q</code>或<code>--count</code>：只显示用户的登录账号和登录用户的数量</li><li><code>-u</code>或<code>--heading</code>：显示列标题</li></ul></li><li><p><code>which</code>：查看命令所在位置，例如<code>which pwd</code></p></li><li><p><code>passwd</code>：修改用户登录密码</p></li><li><p><code>clear</code>：清屏</p></li><li><p><code>shutdown</code>：关机</p></li><li><p><code>reboot</code>：重启</p></li><li><p><code>more</code>：分屏展示</p><ul><li><code>more text.txt</code></li><li><code>q</code>：退出</li><li><code>space</code>：下一页</li><li><code>h</code>：获取帮助</li></ul></li><li><p><code>cat</code>：查看并合并文件内容</p><ul><li><code>cat file1 file2 ...</code>：合并多个文件查看</li></ul></li><li><p>软连接 / 硬链接</p><ul><li>命令格式：<code>ln [-s] 源文件 链接文件</code></li><li><code>ln -s a.txt a_sl</code>：软连接，相当于win下面的快捷方式<ul><li>尽量使用绝对路径</li><li>当源文件大小改变时，链接文件不受影响</li><li>链接文件几乎不占用磁盘空间</li><li>当源文件删除，链接文件失效</li><li>软连接可以链接目录</li></ul></li><li><code>ln b.txt b_sl</code>：硬链接<ul><li>只能链接普通文件，不能链接目录</li><li>链接文件几乎与源文件占用空间一致</li><li>当源文件删除时候，链接文件不受影响</li></ul></li></ul></li><li><p>重定向</p><ul><li><code>ls &gt; test.txt</code>：讲查询结果重定向输出到文件中，若文件不存在则创建。若存在则覆盖</li><li><code>&gt;</code>：输出重定向为覆盖</li><li><code>&gt;&gt;</code>：输出重定向为追加至文件的尾部</li></ul></li><li><p><code>cd [目录名]</code>：切换文件夹</p><ul><li><code>cd .</code>：进入当前路径</li><li><code>cd ..</code>：返回上一级目录</li><li><code>cd /</code>：返回根目录</li><li><code>cd ~</code>：返回home目录</li><li><code>cd -</code>：进入上次所在的目录</li></ul></li></ul><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><ul><li><code>*</code> ：表示所有字符</li><li><code>?</code>：只代表任意一个字符</li><li><code>[a-z]</code>：表示a-z中任意一个字符</li><li><code>\</code>：反斜杠，转义字符</li></ul><h1 id="head-amp-trail"><a href="#head-amp-trail" class="headerlink" title="head &amp; trail"></a>head &amp; trail</h1><ul><li><code>head -n filename</code>：查看文件的前n行</li><li><code>trail -n filename</code>：查看文件的后n行</li><li><code>trail -f filename</code>：动态查看文件的内容</li></ul><h1 id="查看进程和端口号"><a href="#查看进程和端口号" class="headerlink" title="查看进程和端口号"></a>查看进程和端口号</h1><ul><li>进程：<code>ps aux |grep ***</code><ul><li><code>a</code>：all</li><li><code>u</code>：user</li></ul></li><li>端口号：<code>netstat -tnulpa | grep ***</code><ul><li><code>t</code>：tcp</li><li><code>n</code>：no</li><li><code>u</code>：user</li><li><code>l</code>：listen</li><li><code>p</code>：port</li><li><code>a</code>：all</li></ul></li></ul><h1 id="scp-命令"><a href="#scp-命令" class="headerlink" title="scp 命令"></a>scp 命令</h1><ul><li>跨系统复制文件</li><li><code>scp -r 源文件路径 用户名@远程ip地址:目标路径</code></li></ul><h1 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h1><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器</p><ul><li><p>使用格式</p><ul><li><code>top [-] [d] [p] [q] [c] [C] [S] [s]  [n]</code></li></ul></li><li><p>参数说明</p><ul><li><code>d</code> 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 </li><li><code>p</code> 通过指定监控进程ID来仅仅监控某个进程的状态。 </li><li><code>q</code> 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 </li><li><code>S</code> 指定累计模式 </li><li><code>s</code> 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 </li><li><code>i</code> 使top不显示任何闲置或者僵死进程。 </li><li><code>c</code> 显示整个命令行而不只是显示命令名  </li></ul></li><li><p>常用操作</p><ul><li>top   //每隔5秒显式所有进程的资源占用情况</li><li>top -d 2  //每隔2秒显式所有进程的资源占用情况</li><li>top -c  //每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)</li><li>top -p 12345 -p 6789//每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况</li><li>top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1></li></ul></li></ul><p>[1] <a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Linux</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux-的发展史&quot;&gt;&lt;a href=&quot;#linux-的发展史&quot; class=&quot;headerlink&quot; title=&quot;linux 的发展史&quot;&gt;&lt;/a&gt;linux 的发展史&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Unix&lt;/li&gt;
&lt;li&gt;Minix&lt;/li&gt;
&lt;li&gt;Lin
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://hashcode.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://hashcode.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>写在2019的边上</title>
    <link href="https://hashcode.cn/2020/01/02/daily-2020-0102/"/>
    <id>https://hashcode.cn/2020/01/02/daily-2020-0102/</id>
    <published>2020-01-02T06:44:47.000Z</published>
    <updated>2020-11-20T06:12:25.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在2019的边上"><a href="#写在2019的边上" class="headerlink" title="写在2019的边上"></a>写在2019的边上</h2><blockquote><p>只有初恋般的热情和宗教般的意志，人才有可能成就某种事业。路遥</p></blockquote><p>2020年是将会是一个新的十年，前些天从票圈看到20世纪的20年代中国文坛的一些大师，有冰心，鲁迅、郭沫若、老舍、沈从文、巴金、矛盾等。嗯，这个20年代将会发生什么呢？我可以亲身经历并作为一个记录者。把时钟拨回10年之前2010年，那时候我刚刚读高二，没有看过外面的世界，活动半径基本是以家和学校为原点。我试图跳进记忆的洪流去寻找一些重要的时刻，但完全想不起当时光照进2010年的时候，我都在做些什么？有什么念念不忘的事？喜欢哪个女生？只能解释为年纪大了才对时间的流逝更有感触吧。若要说回20年前的2000年，我6岁，从时间的刻度上推算我应该在山西省一个自然村的小学开始了这漫长的求学生涯，那时到是有些许记忆，不过也大多是一些记忆碎片的拼凑。我觉得人生应该就是这样，若没有日复一日的记录，十年已经是一个很长的维度。你无法想起一些具体的事，只能寄思绪于时间的形色中，然后感叹岁月如此变迁，然后好好活着。感慨完毕，说点正事。</p><h2 id="2019我的阅读书单"><a href="#2019我的阅读书单" class="headerlink" title="2019我的阅读书单"></a>2019我的阅读书单</h2><ol><li>许三观卖血记 - 余华</li><li>大江东去（共三部）- 阿耐</li><li>白说 - 白岩松</li><li>1984 - 乔治·奥维尔</li><li>北京折叠 - 郝景芳</li><li>曾国藩家书 - 陈书凯</li><li>一生中最高兴的一天 - 路遥</li><li>路遥传（重新开启平凡的世界）- 厚夫</li><li>黄叶在秋风中飘落 - 路遥</li><li>你怎么也想不到 - 路遥</li><li>奇特的一生 - 格拉宁 / 侯焕闳 / 唐其慈 </li><li>黑客与画家 - Paul Graham / 阮一峰译</li><li>边城 - 沈从文</li><li>月亮与六便士 - 威廉·萨默塞特·毛姆 / 徐淳刚译</li><li>乌合之众 - 勒庞 / 冯克利译</li><li>异类 - 马尔科姆·格拉德威尔 / 季丽娜译</li><li>最好的告别 - 阿图·葛文德</li><li>了不起的盖茨比 - 菲茨杰拉德</li><li>自在独行 - 贾平凹</li><li>青春 - 韩寒</li><li>Lonely Planet 孤独星球：山西（2014年版）</li><li>世界简史 - 赫伯特·乔治·威尔斯</li><li>如何阅读一本书 - 莫提默·J. 艾德勒</li><li>小王子 - 圣埃克苏佩里</li><li>围城 - 钱锺书</li><li>小岛经济学 - 彼得·希夫、安德鲁·希夫</li><li>走到人生边上 - 杨绛</li></ol><p><img src="/images/daily/flagof2019.png" alt="FLAGOF2019"><br>2019年对我来说是收获的一年。考研结束之后，我给自己未来一年立的几个小小的flag，大致可以概括为多读点书，多锻炼身体，保持积极向上和进取的心态。这一年相比往年读的不多也不少，27本，大多数可以用来读书的时间还是都随着生活的硝烟飘散。2018年我跑了425公里，其中有两个半马。如果要为2019没有跑完 500km 找一个说服自己的理由的话（那就是跑步的时间都去游泳了吧？。体重从回到学校时候的80kg减到70kg左右，对于净身高181的我还可以了。英文单词打卡超额完成了100天(嗯，来年就立个300天的flag吧？)，要继续保持，因为没有功利的坚持是很难得的事情呀。</p><h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>从2019/4/10回到学校后，体育运动搞的还不错，虽然跑步的flag打脸了，但是学会了蛙泳，自由泳，平均下来每周至少能光临两次游泳馆。还有羽毛球，篮球。基本每天都是要搞点才是能放心爬上床的。作为一命研究僧，不仅要把学术科研搞好，腰间盘也是不能凸出来的。要继续保持。</p><h2 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h2><p>2019年身边又有几个朋友结婚了，尤其作为伴郎去四川参加了桥老师的婚礼，发现一个问题是如果结婚晚的话，就要找不到好朋友做伴郎了。但人各有志，少年四方。不着急，慢慢来，先完善自己。离开北京之前，跟桥老师喝了大酒。在杭州和远哥喝了大酒。在潍坊和济南没和群哥喝成，有些遗憾。天各一方之后，若想常和好朋友坐在一个桌前把酒喝够，面红耳赤追忆往事与畅想未来，实在是一件奢侈的事情。更多时候的心事都要自己与自己说，这让我更加怀念冬天和夏天的西三旗。也有好的事情，比如开学后也遇到了几个志趣相投的伙伴，虽然年龄都比我小，但时间往前推一些，那些分开的朋友他们也从来不曾嫌我年龄小不是吗？2019年最后一天的晚上我给大家录了新年愿望，我在自己的新年愿望里说：“希望我们十年后还能在一起”。但我又何尝不知道人总是会分开的，而且还会越分越远呢。</p><h2 id="学术"><a href="#学术" class="headerlink" title="学术"></a>学术</h2><p>2019 年的我的学术成果为零。希望 2020 不在这么丢人的写在自己的年终总结里。</p><p><img src="/images/daily/lab_desk.jpeg" alt="实验室的工作台"><br>如果要说这一年最大的收获是什么，那应该得是收到了心心念念的硕士录取通知书。去了灵隐还愿，去了潍坊访师，和317的兄弟在济南相聚。<br>所以离开了北京，离开这座待了五年半的城市。去北京那年我19岁，鲜衣怒马，烈焰繁花。离开的时候25岁，漂泊五载，终觅心海。王小波曾在《万寿寺》的结尾里写到，人只拥有此生此世是不够的，他还应该拥有诗意的人生。</p><p>2020/01/02 太原 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在2019的边上&quot;&gt;&lt;a href=&quot;#写在2019的边上&quot; class=&quot;headerlink&quot; title=&quot;写在2019的边上&quot;&gt;&lt;/a&gt;写在2019的边上&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;只有初恋般的热情和宗教般的意志，人才有可能成就某种事业。路
      
    
    </summary>
    
    
      <category term="Daily" scheme="https://hashcode.cn/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://hashcode.cn/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>Maven 使用快速入门</title>
    <link href="https://hashcode.cn/2019/08/15/java-maven-base/"/>
    <id>https://hashcode.cn/2019/08/15/java-maven-base/</id>
    <published>2019-08-15T02:02:47.000Z</published>
    <updated>2020-11-20T06:12:25.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven是跨平台的项目管理工具，主要服务于基于Java平台的项目构建，依赖管理和项目信息管理，方便jar包的管理且不需要上传至代码托管服务器。类似于iOS平台的 cocoapods 和 android 平台的 gradle。</p><h1 id="安装-Maven-for-mac"><a href="#安装-Maven-for-mac" class="headerlink" title="安装 Maven for mac"></a>安装 Maven for mac</h1><h2 id="下载-Maven"><a href="#下载-Maven" class="headerlink" title="下载 Maven"></a>下载 Maven</h2><p>从 Maven 官方地址：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a> 下载最新版本 apache-maven-3.6.1-bin.tar.gz。<br>bin:存放了 maven 的命令，比如我们前面用到的 mvn tomcat:run<br>boot:存放了一些 maven 本身的引导程序，如类加载器等<br>conf:存放了 maven 的一些配置文件，如 setting.xml 文件<br>lib:存放了 maven 本身运行所需的一些 jar 包</p><h2 id="将-Maven-添加到环境变量"><a href="#将-Maven-添加到环境变量" class="headerlink" title="将 Maven 添加到环境变量"></a>将 Maven 添加到环境变量</h2><p>Maven 下载完毕后，解压到环境变量集合的位置，将其解压在 /usr/local/maven 目录下。<br>然后在终端中，执行如下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open ~/.bash_profile</span><br></pre></td></tr></table></figure><p>打开.bash_profile后，在里面添加如下的 maven 配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Maven config</span></span><br><span class="line"><span class="built_in">export</span> M3_HOME=/usr/<span class="built_in">local</span>/maven/apache-maven-3.6.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$M3_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>保存并关闭文件，然后执行以下命令使最新的环境变量生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h2 id="测试-Maven-是否安装成功"><a href="#测试-Maven-是否安装成功" class="headerlink" title="测试 Maven 是否安装成功"></a>测试 Maven 是否安装成功</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$M3_HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>若输出结果是类似以下的值则表明配置没有问题</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/maven/maven3.3.9</span><br><span class="line">/usr/<span class="built_in">local</span>/maven/maven3.3.9/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/bin:/Users/qiudengqiang/.nvm/versions/node/v9.11.1/bin:/usr/<span class="built_in">local</span>/opt/openssl/bin:/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/VMware Fusion.app/Contents/Public:/Users/qiudengqiang/.rvm/bin::/usr/<span class="built_in">local</span>/mysql/bin</span><br></pre></td></tr></table></figure><p>接下来用maven 的命令查看 maven 版本，鉴定Maven 环境是否安装成功。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure><p>成功时输入以下日志</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Apache Maven 3.6.1 (d66c9c0b3152b2e69ee9bac180bb8fcc8e6af555; 2019-04-05T03:00:29+08:00)</span><br><span class="line">Maven home: /usr/<span class="built_in">local</span>/maven/apache-maven-3.6.1</span><br><span class="line">Java version: 1.8.0_66, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_66.jdk/Contents/Home/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: <span class="string">"mac os x"</span>, version: <span class="string">"10.14.4"</span>, arch: <span class="string">"x86_64"</span>, family: <span class="string">"mac"</span></span><br></pre></td></tr></table></figure><p>至此，maven for mac 环境就配置好了。</p><h1 id="Maven-仓库"><a href="#Maven-仓库" class="headerlink" title="Maven 仓库"></a>Maven 仓库</h1><p>maven 的工作需要从仓库下载一些 jar 包，假如本地的项目 A、项目 B 等都会通过 maven 软件从远程仓库(可以理解为互联网上的仓库)下载 jar 包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此 jar 包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。</p><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><p>本地仓库 :用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包， 优先从本地仓库查找<br>仓库默认的目录在用户目录下：/Users/qiudengqiang/.m2/repository</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库:如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。 远程仓库可以在互联网内也可以在公司的局域网内</p><h2 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h2><p>在 maven 软件中内置一个远程仓库地址 <a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a> ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。</p><h2 id="配置仓库路径"><a href="#配置仓库路径" class="headerlink" title="配置仓库路径"></a>配置仓库路径</h2><p>在与bin同级目录的conf/settings.xml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- localRepository</span><br><span class="line">  | The path to the local repository maven will use to store artifacts.</span><br><span class="line">  |</span><br><span class="line">  | Default: $&#123;user.home&#125;&#x2F;.m2&#x2F;repository</span><br><span class="line"> &lt;localRepository&gt;&#x2F;path&#x2F;to&#x2F;local&#x2F;repo&lt;&#x2F;localRepository&gt;</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><p>在终端中输入:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:system</span><br></pre></td></tr></table></figure><p>maven默认会从上面的服务器(中央仓库) 下载 jar包到本地。</p><h2 id="修改-settings-xml"><a href="#修改-settings-xml" class="headerlink" title="修改 settings.xml"></a>修改 settings.xml</h2><p>在mirrors中添加下面的内容，使用阿里云服务器下载jar包，因为国外的下载太慢了，把国外的注释不用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;!-- mirror</span><br><span class="line">   | Specifies a repository mirror site to use instead of a given repository. The repository that</span><br><span class="line">   | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span><br><span class="line">   | <span class="keyword">for</span> inheritance and direct lookup purposes, and must be unique across the <span class="built_in">set</span> of mirrors.</span><br><span class="line">   |</span><br><span class="line">  &lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;mirrorId&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;Human Readable Name <span class="keyword">for</span> this Mirror.&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">   --&gt;</span><br><span class="line">   &lt;!-- 阿里云maven--&gt;</span><br><span class="line">  &lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;</span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure><h2 id="Maven-项目结构"><a href="#Maven-项目结构" class="headerlink" title="Maven 项目结构"></a>Maven 项目结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ProjectName</span><br><span class="line">  |-src</span><br><span class="line">  |   |-main</span><br><span class="line">  |   |  |-java        —— 存放项目的.java文件</span><br><span class="line">  |   |  |-resources   —— 存放项目资源文件，如spring, hibernate配置文件</span><br><span class="line">  |   |-<span class="built_in">test</span></span><br><span class="line">  |      |-java        ——存放所有测试.java文件，如JUnit测试类</span><br><span class="line">  |      |-resources   —— 测试资源文件</span><br><span class="line">  |-target             —— 目标文件输出位置例如.class、.jar、.war文件</span><br><span class="line">  |-pom.xml           ——maven项目核心配置文件</span><br></pre></td></tr></table></figure><p>「注」：如果是普通的 java 项目，那么就没有 webapp 目录。</p><h1 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h1><h2 id="mvn-compile"><a href="#mvn-compile" class="headerlink" title="mvn compile"></a>mvn compile</h2><p>完成编译操作<br>执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</p><h2 id="mvn-clean"><a href="#mvn-clean" class="headerlink" title="mvn clean"></a>mvn clean</h2><p>执行完毕后，会将target目录删除。</p><h2 id="mvn-test"><a href="#mvn-test" class="headerlink" title="mvn test"></a>mvn test</h2><p>完成单元测试操作<br>执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）</p><h2 id="mvn-package"><a href="#mvn-package" class="headerlink" title="mvn package"></a>mvn package</h2><p>完成打包操作<br>执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war（可以在配置文件中制定目标格式）</p><h2 id="mvn-install"><a href="#mvn-install" class="headerlink" title="mvn install"></a>mvn install</h2><p>执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作<br>执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用</p><h2 id="mvn-组合命令"><a href="#mvn-组合命令" class="headerlink" title="mvn 组合命令"></a>mvn 组合命令</h2><p>mvn clean compile<br>mvn clean test<br>mvn clean package<br>mvn clean install</p><h1 id="Maven-的核心概念"><a href="#Maven-的核心概念" class="headerlink" title="Maven 的核心概念"></a>Maven 的核心概念</h1><p>在平面几何中坐标（x,y）可以标识平面中唯一的一点。在maven中坐标就是为了定位一个唯一确定的jar包。我们需要找一个用来唯一标识一个构建的统一规范，拥有了统一规范，就可以把查找工作交给机器，Maven坐标主要组成(GAV) 确定一个jar在互联网位置。<br>groupId：定义当前Maven组织名称<br>artifactId：定义实际项目名称<br>version：定义当前项目的当前版本</p><h2 id="坐标的查找"><a href="#坐标的查找" class="headerlink" title="坐标的查找"></a>坐标的查找</h2><p>访问<a href="http://www.mvnrepository.com或者http://search.maven.org/网站" target="_blank" rel="noopener">http://www.mvnrepository.com或者http://search.maven.org/网站</a><br>假设搜索所spring core,如图然后点击sping,接点选择所需要的版本，就能看到所需要的jar包了<br><img src="/images/tech/maven-spring-core.png" alt="spring core"></p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="scope-依赖范围"><a href="#scope-依赖范围" class="headerlink" title="scope 依赖范围"></a>scope 依赖范围</h3><p><img src="/images/tech/maven-dependency-scope.png" alt="spring core"></p><p>其中依赖范围scope 用来控制依赖和编译，测试，运行的 classpath 的关系. 主要的是三种依赖关系如下：</p><ul><li><code>compile</code> ： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效</li><li><code>test</code> ：测试依赖范围。只对于测试classpath有效</li><li><code>provided</code> ：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api</li><li><code>runtime</code> :运行时提供。例如:jdbc驱动</li></ul><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>直接依赖和间接依赖<br>test2 依赖 test1，test3依赖test2<br>test2 直接依赖 test1，test3间接依赖test1<br><img src="/images/tech/maven-transport-dependency.png" alt="transport dependency"><br>当第二依赖的范围是compile的时候，依赖可以传递<br>当第二直接依赖的范围是test的时候，依赖不会传递<br>provided和runtime一般很少用</p><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p>假如test1使用junit4.10依赖,并且scope是compile,那test2,test3都可以使用test1的junit4.10，因为传递下来了<br>假如test2使用junit4.9依赖，那test3会使用【就近的一个依赖】，也就是使用junit4.9</p><h3 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h3><p><code>&lt;optional&gt; true/false&lt;optional&gt;</code> 是否可选，也可以理解为是否向下传递。<br>在依赖中添加optional选项决定此依赖是否向下传递，如果是true则不传递，如果是false就传递，默认为false<br><img src="/images/tech/maven-optional-dependency.png" alt="optional dependency"></p><h3 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h3><p>exclusions可用于排除依赖,注意exclusions是写在dependency中<br><img src="/images/tech/maven-exclusions-dependency.png" alt="optional dependency"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Maven生命周期就是为了对所有的构建过程进行抽象和统一。<br>包括项目清理、初始化、编译、打包、测试、部署等几乎所有构建步骤。<br>生命周期可以理解为构建工程的步骤。</p><p>在Maven中有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是：<br>Clean Lifecycle： 在进行真正的构建之前进行一些清理工作。<br>Default Lifecycle： 构建的核心部分，编译，测试，打包，部署等等。<br>Site Lifecycle： 生成项目报告，站点，发布站点。 </p><h3 id="Clean生命周期：清理项目"><a href="#Clean生命周期：清理项目" class="headerlink" title="Clean生命周期：清理项目"></a>Clean生命周期：清理项目</h3><p>pre-clean 执行一些需要在clean之前完成的工作<br>clean 移除所有上一次构建生成的文件<br>post-clean 执行一些需要在clean之后立刻完成的工作 </p><p>也就是说，mvn clean 等同于 mvn pre-clean clean<br>如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。<br>这是Maven很重要的一个规则，可以大大简化命令行的输入。</p><h3 id="Default生命周期：构造项目"><a href="#Default生命周期：构造项目" class="headerlink" title="Default生命周期：构造项目"></a>Default生命周期：构造项目</h3><p>Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">validate </span><br><span class="line">generate-sources </span><br><span class="line">process-sources </span><br><span class="line">generate-resources </span><br><span class="line">process-resources 复制并处理资源文件，至目标目录，准备打包。 </span><br><span class="line">compile 编译项目的源代码。 </span><br><span class="line">process-classes </span><br><span class="line">generate-test-sources </span><br><span class="line">process-test-sources </span><br><span class="line">generate-test-resources </span><br><span class="line">process-test-resources 复制并处理资源文件，至目标测试目录。 </span><br><span class="line"><span class="built_in">test</span>-compile 编译测试源代码。 </span><br><span class="line">process-test-classes </span><br><span class="line"><span class="built_in">test</span> 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 </span><br><span class="line">prepare-package </span><br><span class="line">package 接受编译好的代码，打包成可发布的格式，如 JAR 。 </span><br><span class="line">pre-integration-test </span><br><span class="line">integration-test </span><br><span class="line">post-integration-test </span><br><span class="line">verify </span><br><span class="line">install 将包安装至本地仓库，以让其它项目依赖。 </span><br><span class="line">deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享</span><br></pre></td></tr></table></figure><p>运行任何一个阶段的时候，它前面的所有阶段都会被运行<br>这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包，安装到本地仓库<br>此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要。</p><h2 id="Maven-工程的运行"><a href="#Maven-工程的运行" class="headerlink" title="Maven 工程的运行"></a>Maven 工程的运行</h2><p>进入 maven 工程目录(当前目录有 pom.xml 文件)，运行 tomcat:run 命令。<br><img src="/images/tech/maven-tomcat-run.png" alt="maven-tomcat-run"><br>根据上边的提示信息，通过浏览器访问:<a href="http://localhost:8080/maven-helloworld/" target="_blank" rel="noopener">http://localhost:8080/maven-helloworld/</a></p><h2 id="Maven-的概念模型"><a href="#Maven-的概念模型" class="headerlink" title="Maven 的概念模型"></a>Maven 的概念模型</h2><p><img src="/images/tech/maven-concept-model.png" alt="maven-tomcat-run"></p><h3 id="项目对象模型-Project-Object-Model"><a href="#项目对象模型-Project-Object-Model" class="headerlink" title="项目对象模型 (Project Object Model)"></a>项目对象模型 (Project Object Model)</h3><p>一个 maven 工程都有一个 pom.xml 文件，通过 pom.xml 文件定义项目的坐标、项目依赖、项目信息、 插件目标等。</p><h3 id="依赖管理系统-Dependency-Management-System"><a href="#依赖管理系统-Dependency-Management-System" class="headerlink" title="依赖管理系统(Dependency Management System)"></a>依赖管理系统(Dependency Management System)</h3><p>通过maven的依赖管理对项目所依赖的jar 包进行统一管理。<br>比如:项目依赖 junit4.9，通过在 pom.xml 中定义 junit4.9 的依赖即使用 junit4.9，如下所示是 junit4.9 的依赖定义:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖关系 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此项目运行使用 junit，所以此项目依赖 junit --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- junit 的项目名称 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- junit 的模块名称 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- junit 版本 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖范围:单元测试时使用 junit --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="一个项目生命周期-Project-Lifecycle"><a href="#一个项目生命周期-Project-Lifecycle" class="headerlink" title="一个项目生命周期(Project Lifecycle)"></a>一个项目生命周期(Project Lifecycle)</h3><p>使用 maven 完成项目的构建，项目构建包括:清理、编译、测试、部署等过程，maven 将这些<br>过程规范为一个生命周期，如下所示是生命周期的各个阶段:<br><img src="/images/tech/maven-project-lifecycle.png" alt="maven-project-life-cycle"><br>maven 通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行 mvn compile 执行编译、<br>执行 mvn clean 执行清理。</p><h3 id="一组标准集合"><a href="#一组标准集合" class="headerlink" title="一组标准集合"></a>一组标准集合</h3><p>maven 将整个项目管理过程定义一组标准，比如:通过 maven 构建工程有标准的目录结构，有<br>标准的生命周期阶段、依赖管理有标准的坐标定义等。</p><h3 id="插件-plugin-目标-goal"><a href="#插件-plugin-目标-goal" class="headerlink" title="插件(plugin)目标(goal)"></a>插件(plugin)目标(goal)</h3><p>maven 管理项目生命周期过程都是基于插件完成的。</p><h1 id="IDEA-开发-Maven-项目"><a href="#IDEA-开发-Maven-项目" class="headerlink" title="IDEA 开发 Maven 项目"></a>IDEA 开发 Maven 项目</h1><p>在通常在开发的环境中，我们都会使用流行的工具来开发项目。</p><h2 id="IDEA-的-Maven-配置"><a href="#IDEA-的-Maven-配置" class="headerlink" title="IDEA 的 Maven 配置"></a>IDEA 的 Maven 配置</h2><p><img src="/images/tech/maven-idea-setting.png" alt="maven-idea-setting"></p><h2 id="IDEA-中创建一个-Maven-的-web-工程"><a href="#IDEA-中创建一个-Maven-的-web-工程" class="headerlink" title="IDEA 中创建一个 Maven 的 web 工程"></a>IDEA 中创建一个 Maven 的 web 工程</h2><p>打开 idea，选择创建一个新工程，选择 idea 提供好的 maven 的 web 工程模板<br><img src="/images/tech/maven-idea-create-web-project.png" alt="maven-idea-project"><br>点击 Next 填写项目信息<br><img src="/images/tech/maven-idea-create-project-gav.png" alt="maven-idea-project-gav"><br>点击 Next，此处不做改动。<br><img src="/images/tech/maven-idea-project-mul.png" alt="maven-idea-mul"><br>点击 Next 选择项目所在目录<br><img src="/images/tech/maven-idea-create-pp.png" alt="maven-idea-pp"><br>点击 Finish 后开始创建工程，耐心等待，直到出现如下界面。<br><img src="/images/tech/maven-idea-project-catalogue.png" alt="maven-idea-project-catalogue"><br>手动添加 src/main/java 目录，如下图右键 main 文件夹-New-Directory,创建一个新的文件夹命名为 java<br><img src="/images/tech/maven-idea-project-adddir.png" alt="maven-idea-project-adddir"><br>点击 OK 后，在新的文件夹 java 上右键 Make Directory as Sources Root<br><img src="/images/tech/maven-idea-make-as-source-root.png" alt="maven-idea-project-source-root"></p><h3 id="创建一个-Servlet"><a href="#创建一个-Servlet" class="headerlink" title="创建一个 Servlet"></a>创建一个 Servlet</h3><p>src/java/main 创建了一个 Servlet，但报错<br><img src="/images/tech/maven-idea-servlet-error.png" alt="maven-idea-project-servlet-error"><br>要解决问题，就是要将 servlet-api-xxx.jar 包放进来，作为 maven 工程应当添加 servlet 的坐标，从而 导入它的 jar</p><h3 id="在-pom-xml-文件添加坐标"><a href="#在-pom-xml-文件添加坐标" class="headerlink" title="在 pom.xml 文件添加坐标"></a>在 pom.xml 文件添加坐标</h3><p>直接打开 hello_maven 工程的 pom.xml 文件，再添加坐标<br><img src="/images/tech/maven-idea-pom-add-gav.png" alt="maven-idea-pom-add-gav"></p><p>添加 jar 包的坐标时，还可以指定这个 jar 包将来的作用范围。<br>每个 maven 工程都需要定义本工程的坐标，坐标是 maven 对 jar 包的身份定义，比如:入门程序的 坐标定义如下:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模块名称 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello_maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span> &gt;</span> :打包类型</span><br><span class="line">    jar:执行 package 会打成 jar 包</span><br><span class="line">    war:执行 package 会打成 war 包</span><br><span class="line">pom :用于 maven 工程的继承，通常父工程设置为 pom</span><br></pre></td></tr></table></figure><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包括:</p><p><code>compile</code>:编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在 编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。<br><code>provided</code>:provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用， provided依 赖在编译和测试时需要，在运行时不需要，比如:servlet api 被 tomcat 容器提供。<br>runtime:runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如:jdbc 的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。<br><code>test</code>:test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用， 比如:junit。由于运行时不需要所以 test 范围依赖不会被打包。<br><code>system</code>:system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径，需要指定 systemPath 磁盘路径，system 依赖不推荐使用。<br><img src="/images/tech/maven-depedency-scope02.png" alt="maven-dependency-scope"></p><p>在 maven-web 工程中测试各个 scop。</p><h3 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a>测试总结</h3><p> 默认引入 的 jar 包 ——- compile 【默认范围 可以不写】(编译、测试、运行 都有效 )<br> servlet-api 、jsp-api ——- provided (编译、测试 有效， 运行时无效 防止和 tomcat 下 jar 冲突)  jdbc 驱动 jar 包 —- runtime (测试、运行 有效 )<br> junit —– test (测试有效)<br>依赖范围由强到弱的顺序是:compile&gt;provided&gt;runtime&gt;test</p><h2 id="设置-JDK-编译版本"><a href="#设置-JDK-编译版本" class="headerlink" title="设置 JDK 编译版本"></a>设置 JDK 编译版本</h2><p>本教程使用 jdk1.8，需要设置编译版本为 1.8，这里需要使用 maven 的插件来设置:<br>在 pom.xml 中加入:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加-tomcat7-插件"><a href="#添加-tomcat7-插件" class="headerlink" title="添加 tomcat7 插件"></a>添加 tomcat7 插件</h2><p>在 pom 文件中添加如下内容<br><img src="/images/tech/maven-pom-tomcat7.png" alt="maven-pom-tomcat7"><br>此时点击 idea 最右侧 Maven Projects， 就可以看到我们新添加的 tomcat7 插件<br>双击 tomcat7 插件下 tomcat7:run 命令直接运行项目<br><img src="/images/tech/maven-idea-tomcat7-run.png" alt="maven-pom-tomcat7"><br>也可以直接点击如图按钮，手动输入 tomc7:run 命令运行项目<br><img src="/images/tech/maven-idea-type-tomcat7-run.png" alt="maven-pom-tomcat7"><br>点击后弹出如下图窗口<br><img src="/images/tech/maven-idea-tomcat7-run02.png" alt="maven-pom-tomcat7"></p><h1 id="Maven-工程运行调试"><a href="#Maven-工程运行调试" class="headerlink" title="Maven 工程运行调试"></a>Maven 工程运行调试</h1><h2 id="端口占用处理"><a href="#端口占用处理" class="headerlink" title="端口占用处理"></a>端口占用处理</h2><p>重新执行 tomcat:run 命令重启工程，重启之前需手动停止 tomcat，否则报下边的错误:<br><img src="/images/tech/maven-port-conflict.png" alt="maven-pom-tomcat7"></p><h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><p>点击如图所示选项<br><img src="/images/tech/maven-idea-debug-edit.png" alt="maven-idea-debug-edit"><br>在弹出框中点击如图加号按钮找到 maven 选项<br><img src="/images/tech/maven-idea-debug-option.png" alt="maven-idea-debug-option"><br>在弹出窗口中填写如下信息<br><img src="/images/tech/maven-idea-debug-edit-fill.png" alt="maven-idea-debug-edit-fill"><br>完成后先 Apply 再 OK 结束配置后，可以在主界面找到我们刚才配置的操作名称。<br><img src="/images/tech/maven-idea-debug-window-btn.png" alt="maven-idea-debug-window-btn"><br>如上图红框选中的两个按钮，左侧是正常启动，右侧是 debug 启动。</p><h2 id="pom-文件描述"><a href="#pom-文件描述" class="headerlink" title="pom 文件描述"></a>pom 文件描述</h2><p>pom.xml 是 Maven 项目的核心配置文件，位于每个工程的根目录，基本配置如下:</p><p><code>&lt;project &gt;</code> :文件的根节点 .<br><code>&lt;modelversion &gt;</code> : pom.xml 使用的对象模型版本<br><code>&lt;groupId &gt;</code> :项目名称，一般写项目的域名<br><code>&lt;artifactId &gt;</code> :模块名称，子项目名或模块名称<br><code>&lt;version &gt;</code> :产品的版本号 .<br><code>&lt;packaging &gt;</code> :打包类型，一般有 jar、war、pom 等<br><code>&lt;name &gt;</code> :项目的显示名，常用于 Maven 生成的文档。<br><code>&lt;description &gt;</code> :项目描述，常用于 Maven 生成的文档<br><code>&lt;dependencies&gt;</code> :项目依赖构件配置，配置项目依赖构件的坐标<br><code>&lt;build&gt;</code> :项目构建配置，配置编译、运行插件等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven是跨平台的项目管理工
      
    
    </summary>
    
    
      <category term="Java" scheme="https://hashcode.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://hashcode.cn/tags/Java/"/>
    
      <category term="Web" scheme="https://hashcode.cn/tags/Web/"/>
    
      <category term="Maven" scheme="https://hashcode.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Redis 使用快速入门</title>
    <link href="https://hashcode.cn/2019/08/13/web-redis-base/"/>
    <id>https://hashcode.cn/2019/08/13/web-redis-base/</id>
    <published>2019-08-13T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>redis是一款高性能的NOSQL系列的非关系型数据库</p><h2 id="什么是NOSQL"><a href="#什么是NOSQL" class="headerlink" title="什么是NOSQL"></a>什么是NOSQL</h2><p>NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。<br>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p><h3 id="NOSQL和关系型数据库比较"><a href="#NOSQL和关系型数据库比较" class="headerlink" title="NOSQL和关系型数据库比较"></a>NOSQL和关系型数据库比较</h3><ul><li>优点：</li></ul><ol><li>成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</li><li>查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</li><li>存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</li><li>扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</li></ol><ul><li>缺点：</li></ul><ol><li>维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。</li><li>不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</li><li>不提供关系型数据库对事务的处理。</li></ol><h3 id="非关系型数据库的优势"><a href="#非关系型数据库的优势" class="headerlink" title="非关系型数据库的优势"></a>非关系型数据库的优势</h3><ol><li>性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li>可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ol><h3 id="关系型数据库的优势"><a href="#关系型数据库的优势" class="headerlink" title="关系型数据库的优势"></a>关系型数据库的优势</h3><ol><li>复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，<br>让NoSQL数据库对关系型数据库的不足进行弥补。<br>一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p><h2 id="主流的NOSQL产品"><a href="#主流的NOSQL产品" class="headerlink" title="主流的NOSQL产品"></a>主流的NOSQL产品</h2><h3 id="键值-Key-Value-存储数据库"><a href="#键值-Key-Value-存储数据库" class="headerlink" title="键值(Key-Value)存储数据库"></a>键值(Key-Value)存储数据库</h3><p>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB<br>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。<br>数据模型： 一系列键值对<br>优势： 快速查询<br>劣势： 存储的数据缺少结构化</p><h3 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h3><p>相关产品：Cassandra, HBase, Riak<br>典型应用：分布式的文件系统<br>数据模型：以列簇式存储，将同一列数据存在一起<br>优势：查找速度快，可扩展性强，更容易进行分布式扩展<br>劣势：功能相对局限</p><h3 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h3><p>相关产品：CouchDB、MongoDB<br>典型应用：Web应用（与Key-Value类似，Value是结构化的）<br>数据模型： 一系列键值对<br>优势：数据结构要求不严格<br>劣势： 查询性能不高，而且缺乏统一的查询语法</p><h3 id="图形-Graph-数据库"><a href="#图形-Graph-数据库" class="headerlink" title="图形(Graph)数据库"></a>图形(Graph)数据库</h3><p>相关数据库：Neo4J、InfoGrid、Infinite Graph<br>典型应用：社交网络<br>数据模型：图结构<br>优势：利用图结构相关算法。<br>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求，读的速度是110000次/s，写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p><ol><li>字符串类型 string</li><li>哈希类型 hash</li><li>列表类型 list</li><li>集合类型 set</li><li>有序集合类型 sortedset</li></ol><h3 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h3><p>•    缓存（数据查询、短连接、新闻内容、商品内容等等）<br>•    聊天室的在线好友列表<br>•    任务队列。（秒杀、抢购、12306等等）<br>•    应用排行榜<br>•    网站访问统计<br>•    数据过期处理（可以精确到毫秒<br>•    分布式集群架构中的session分离</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>官网：<a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a><br>中文网：<a href="http://www.redis.net.cn/" target="_blank" rel="noopener">http://www.redis.net.cn/</a><br><a href="https://www.jianshu.com/p/3bdfda703552" target="_blank" rel="noopener">mac os下配置redis参考</a></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol><li>进入redis安装目录<br>cd /usr/local/Cellar/redis/5.0.5/bin </li><li>redis配置文件目录<br>cd /usr/local/etc/redis.conf</li><li>启动redis服务<br>redis-server</li><li>关闭redis服务<br>control+c 或者 找到redis对应的pid服务 kill -9 Pid 杀死服务进程即可</li><li>可以在终端窗口使用 redis-cli 来操作redis服务</li></ol><h1 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h1><h2 id="redis的数据结构："><a href="#redis的数据结构：" class="headerlink" title="redis的数据结构："></a>redis的数据结构：</h2><p>redis存储的是：key,value 格式的数据，其中key都是字符串，value有5种不同的数据结构<br>value的数据结构：<br>    1) 字符串类型 string<br>    2) 哈希类型 hash ： map格式<br>    3) 列表类型 list ： linkedlist格式。支持重复元素<br>    4) 集合类型 set  ： 不允许重复元素<br>    5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序<br><img src="/images/tech/web-redis-value-data-structure.bmp" alt="数据结构"></p><h2 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型 string"></a>字符串类型 string</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p><code>set key value</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> username zhangsan</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p><code>get key</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get username</span><br><span class="line"><span class="string">"zhangsan"</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>del key</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h2 id="哈希类型-hash"><a href="#哈希类型-hash" class="headerlink" title="哈希类型 hash"></a>哈希类型 hash</h2><h3 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h3><p><code>hset key field value</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash password 123</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h3><ul><li><code>hget key field</code>: 获取指定的field对应的值<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget myhash username</span><br><span class="line"><span class="string">"lisi"</span></span><br></pre></td></tr></table></figure></li><li><code>hgetall key</code>：获取所有的field和value<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">"username"</span></span><br><span class="line">2) <span class="string">"lisi"</span></span><br><span class="line">3) <span class="string">"password"</span></span><br><span class="line">4) <span class="string">"123"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p><code>hdel key field</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel myhash username</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h2 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型 list"></a>列表类型 list</h2><p>可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><ol><li><code>lpush key value</code>: 将元素加入列表左表</li><li><code>rpush key value</code>: 将元素加入列表右边<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush myList b</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="获取-2"><a href="#获取-2" class="headerlink" title="获取"></a>获取</h3></li></ol><ul><li><code>lrange key start end</code> ：范围获取<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1</span><br><span class="line">1) <span class="string">"b"</span></span><br><span class="line">2) <span class="string">"a"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br></pre></td></tr></table></figure><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3></li><li><code>lpop key</code> ： 删除列表最左边的元素，并将元素返回</li><li><code>rpop key</code> ： 删除列表最右边的元素，并将元素返回</li></ul><h2 id="集合类型-set"><a href="#集合类型-set" class="headerlink" title="集合类型 set"></a>集合类型 set</h2><p>不允许重复元素</p><h3 id="存储-2"><a href="#存储-2" class="headerlink" title="存储"></a>存储</h3><p><code>sadd key value</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="获取-3"><a href="#获取-3" class="headerlink" title="获取"></a>获取</h3><p><code>smembers key</code>:获取set集合中所有元素</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><h3 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h3><p><code>srem key value</code>:删除set集合中的某个元素    </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem myset a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h2 id="有序集合类型-sortedset"><a href="#有序集合类型-sortedset" class="headerlink" title="有序集合类型 sortedset"></a>有序集合类型 sortedset</h2><p>不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><h3 id="存储-3"><a href="#存储-3" class="headerlink" title="存储"></a>存储</h3><p><code>zadd key score value</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd mysort 60 zhangsan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="获取-4"><a href="#获取-4" class="headerlink" title="获取"></a>获取</h3><p><code>zrange key start end [withscores]</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line">1) <span class="string">"lisi"</span></span><br><span class="line">2) <span class="string">"zhangsan"</span></span><br><span class="line">3) <span class="string">"wangwu"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</span><br><span class="line">1) <span class="string">"zhangsan"</span></span><br><span class="line">2) <span class="string">"60"</span></span><br><span class="line">3) <span class="string">"wangwu"</span></span><br><span class="line">4) <span class="string">"80"</span></span><br><span class="line">5) <span class="string">"lisi"</span></span><br><span class="line">6) <span class="string">"500"</span></span><br></pre></td></tr></table></figure><h3 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h3><p><code>zrem key value</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem mysort lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ol><li><code>keys *</code> : 查询所有的键</li><li><code>type key</code> : 获取键对应的value的类型</li><li><code>del key</code> : 删除指定的key value</li></ol><h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><p>redis是一个内存数据库，当redis服务器重启，或者电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>默认方式，不需要进行配置，默认就使用这种机制；在一定的间隔时间中，检测key的变化情况，然后持久化数据</p><p>1.打开<code>/usr/local/etc</code> 编辑<code>redis.conf</code>文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   after 900 sec (15 min) if at least 1 key changed</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment">#   after 300 sec (5 min) if at least 10 keys changed</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment">#   after 60 sec if at least 10000 keys changed</span></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><ol start="2"><li>重新启动redis服务器并制定配置文件<br>redis-server /usr/local/etc/redis.conf<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2>日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据<br>打开<code>/usr/local/etc</code> 编辑<code>redis.conf</code>文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no（关闭aof） --&gt; appendonly yes （开启aof）</span><br><span class="line"><span class="comment"># appendfsync always ： 每一次操作都进行持久化</span></span><br><span class="line">appendfsync everysec ： 每隔一秒进行一次持久化</span><br><span class="line"><span class="comment"># appendfsync no ： 不进行持久化</span></span><br></pre></td></tr></table></figure><h1 id="使用Java操作redis"><a href="#使用Java操作redis" class="headerlink" title="使用Java操作redis"></a>使用Java操作redis</h1>Jedis: 一款java操作redis数据库的工具.<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2></li><li>下载jedis的jar包</li><li>使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line">jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li></ol><h2 id="Jedis操作各种redis中的数据结构"><a href="#Jedis操作各种redis中的数据结构" class="headerlink" title="Jedis操作各种redis中的数据结构"></a>Jedis操作各种redis中的数据结构</h2><h3 id="字符串类型-string-1"><a href="#字符串类型-string-1" class="headerlink" title="字符串类型 string"></a>字符串类型 string</h3><p><code>set</code>/<code>get</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line"><span class="comment">//存储</span></span><br><span class="line">jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">String username = jedis.get(<span class="string">"username"</span>);</span><br><span class="line">System.out.println(username);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用setex()方法存储可以指定过期时间的 key value</span></span><br><span class="line">jedis.setex(<span class="string">"activecode"</span>,<span class="number">20</span>,<span class="string">"hehe"</span>);<span class="comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="哈希类型-hash-1"><a href="#哈希类型-hash-1" class="headerlink" title="哈希类型 hash"></a>哈希类型 hash</h3><p> map格式<br><code>hset</code>/<code>hget</code>/<code>hgetAll</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line"><span class="comment">// 存储hash</span></span><br><span class="line">jedis.hset(<span class="string">"user"</span>,<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line">jedis.hset(<span class="string">"user"</span>,<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">jedis.hset(<span class="string">"user"</span>,<span class="string">"gender"</span>,<span class="string">"female"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取hash</span></span><br><span class="line">String name = jedis.hget(<span class="string">"user"</span>, <span class="string">"name"</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// keyset</span></span><br><span class="line">Set&lt;String&gt; keySet = user.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    <span class="comment">//获取value</span></span><br><span class="line">    String value = user.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="列表类型-list-1"><a href="#列表类型-list-1" class="headerlink" title="列表类型 list"></a>列表类型 list</h3><p>linkedlist格式。支持重复元素<br><code>lpush / rpush</code><br><code>lpop / rpop</code><br><code>lrange start end</code>: 范围获取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line"><span class="comment">// list 存储</span></span><br><span class="line">jedis.lpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从左边存</span></span><br><span class="line">jedis.rpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从右边存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list 范围获取</span></span><br><span class="line">List&lt;String&gt; mylist = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(mylist);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 弹出</span></span><br><span class="line">String element1 = jedis.lpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">System.out.println(element1);</span><br><span class="line"></span><br><span class="line">String element2 = jedis.rpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">System.out.println(element2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 范围获取</span></span><br><span class="line">List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(mylist2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="集合类型-set-1"><a href="#集合类型-set-1" class="headerlink" title="集合类型 set"></a>集合类型 set</h3><p>不允许重复元素<br><code>sadd</code><br><code>smembers</code>:获取所有元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// set 存储</span></span><br><span class="line">jedis.sadd(<span class="string">"myset"</span>,<span class="string">"java"</span>,<span class="string">"php"</span>,<span class="string">"c++"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 获取</span></span><br><span class="line">Set&lt;String&gt; myset = jedis.smembers(<span class="string">"myset"</span>);</span><br><span class="line">System.out.println(myset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="有序集合类型-sortedset-1"><a href="#有序集合类型-sortedset-1" class="headerlink" title="有序集合类型 sortedset"></a>有序集合类型 sortedset</h3><p>不允许重复元素，且元素有顺序<br><code>zadd</code><br><code>zrange</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line"><span class="comment">//2. 操作</span></span><br><span class="line"><span class="comment">// sortedset 存储</span></span><br><span class="line">jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">3</span>,<span class="string">"亚瑟"</span>);</span><br><span class="line">jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">30</span>,<span class="string">"后裔"</span>);</span><br><span class="line">jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">55</span>,<span class="string">"孙悟空"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sortedset 获取</span></span><br><span class="line">Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">"mysortedset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(mysortedset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h2 id="Jedis连接池-JedisPool"><a href="#Jedis连接池-JedisPool" class="headerlink" title="Jedis连接池 JedisPool"></a>Jedis连接池 JedisPool</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>创建JedisPool连接池对象</li><li>调用方法 <code>getResource()</code>方法获取Jedis连接<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.创建一个配置对象</span></span><br><span class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line"><span class="comment">//3. 使用</span></span><br><span class="line">jedis.set(<span class="string">"hehe"</span>,<span class="string">"heihei"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="连接池工具类"><a href="#连接池工具类" class="headerlink" title="连接池工具类"></a>连接池工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">"maxTotal"</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">"maxIdle"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">"host"</span>),Integer.parseInt(pro.getProperty(<span class="string">"port"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取连接方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1></li></ol><p><strong>「注意」</strong>：使用redis缓存一些不经常发生变化的数据。</p><ul><li>数据库的数据一旦发生改变，则需要更新缓存。</li><li>数据库的表执行增删改的相关操作，需要将redis缓存数据清空，再次存入</li><li>在service层对应的增删改方法中，将redis数据删除。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;redis是一款高性能的NOSQL系列的非关系型数据库&lt;/p&gt;
&lt;h2 id=&quot;什么是NOSQL&quot;&gt;&lt;a href=&quot;#什么是NOSQL&quot; 
      
    
    </summary>
    
    
      <category term="DataBase" scheme="https://hashcode.cn/categories/DataBase/"/>
    
    
      <category term="Web" scheme="https://hashcode.cn/tags/Web/"/>
    
      <category term="Redis" scheme="https://hashcode.cn/tags/Redis/"/>
    
      <category term="DataBase" scheme="https://hashcode.cn/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>jQuery &amp; Ajax 快速入门</title>
    <link href="https://hashcode.cn/2019/08/12/web-jquery-ajax-base/"/>
    <id>https://hashcode.cn/2019/08/12/web-jquery-ajax-base/</id>
    <published>2019-08-12T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p><h2 id="JavaScript-回顾"><a href="#JavaScript-回顾" class="headerlink" title="JavaScript 回顾"></a>JavaScript 回顾</h2><p>JavaScript核心 — JavaScript 语言的核心，定义了语言中基本语法<br>DOM  — Document Object Model 文档对象模型 w3c<br>BOM  — Broswer Object Model 浏览器对象模型</p><h2 id="jQuery-基础"><a href="#jQuery-基础" class="headerlink" title="jQuery 基础"></a>jQuery 基础</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li>下载JQuery<h4 id="目前jQuery有三个大版本："><a href="#目前jQuery有三个大版本：" class="headerlink" title="目前jQuery有三个大版本："></a>目前jQuery有三个大版本：</h4><pre><code>1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，        功能不再新增。因此一般项目来说，使用1.x版本就可以了，        最终版本：1.12.4 (2016年5月20日)2.x：不兼容ie678，很少有人使用，官方只做BUG维护，        功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，        最终版本：2.2.4 (2016年5月20日)3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，        一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。        目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）</code></pre><h4 id="jquery-xxx-js-与-jquery-xxx-min-js区别："><a href="#jquery-xxx-js-与-jquery-xxx-min-js区别：" class="headerlink" title="jquery-xxx.js 与 jquery-xxx.min.js区别："></a>jquery-xxx.js 与 jquery-xxx.min.js区别：</h4><pre><code>1. jquery-xxx.js：开发版本。给程序员使用，有良好的缩进和注释。体积大一些2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快</code></pre></li><li>引入jQuery<br>直接将 jQuery 核心 js 文件加入到工程，一般放置在 web 应用的非 WEB-INF 文件夹，在 html 页面中使用以下代码引入就可以在这个页面中使用 jQuery 了。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js文件所在的位置"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = $(<span class="string">"#div1"</span>);</span><br><span class="line">alert(div1.html());</span><br></pre></td></tr></table></figure></li></ol><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><ol><li><code>#id</code><br> 用法:<code>$(&quot;#myDiv&quot;)</code>  ;  返回值 : 单个元素的组成的集合<br> 说明: 这个就是直接选择 html 中的<code>id=&quot;myDiv&quot;</code></li><li><code>Element</code><br> 用法: <code>$(&quot;div&quot;)</code> ;    返回值 : 集合元素<br> 说明: element 的英文翻译过来是「元素」，所以 element 其实就是 html 已经定义的标签元素，例如 div， input， a等等</li><li><code>class</code><br> 用法: <code>$(&quot;.myClass&quot;)</code> ;     返回值 : 集合元素<br> 说明: 这个标签是直接选择 html 代码中<code>class=&quot;myClass&quot;</code>的元素或元素组（因为在同一html页面中class是可以存在多个同样值的）</li><li><code>*</code><br> 用法: <code>$(&quot;*&quot;)</code> ;     返回值 : 集合元素<br> 说明: 匹配所有元素，多用于结合上下文来搜索</li><li><code>selector1, selector2, selectorN</code><br> 用法: <code>$(&quot;div,span,p.myClass&quot;)</code>;    返回值 : 集合元素<br> 说明: 将每一个选择器匹配到的元素合并后一起返回。可以指定任意多个选择器， 并将匹配到的元素合并到一个结果内。其中<code>p.myClass</code>是表示匹配元素</li></ol><h4 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h4><ol start="6"><li><code>ancestor descendant</code><br> 用法: <code>$(&quot;form input&quot;)</code> ;   返回值 : 集合元素<br> 说明: 在给定的祖先元素下匹配所有后代元素。这个要和下面的<code>parent &gt; child</code>区分开.</li><li><code>parent &gt; child</code><br> 用法: <code>$(&quot;form &gt; input&quot;)</code> ;    返回值 : 集合元素<br> 说明: 在给定的父元素下匹配所有子元素。注意:要区分好后代元素与子元素</li><li><code>prev + next</code><br> 用法: <code>$(&quot;label + input&quot;)</code> ;   返回值 : 集合元素<br> 说明: 匹配所有紧接在 prev 元素后的 next 元素</li><li><code>prev ~ siblings</code><br> 用法: <code>$(&quot;form ~ input&quot;)</code> ;    返回值 : 集合元素<br> 说明: 匹配 prev 元素之后的所有 siblings 元素。<br> 注意: 是匹配之后的元素，不包含该元素在内，并且 siblings 匹配的是和 prev 同辈的元素，其后辈元素不被匹配。</li></ol><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li><p>事件绑定</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取b1按钮</span></span><br><span class="line">$(<span class="string">"#b1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"abc"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>入口函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下方法等同于window.onload</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p><strong>[注意]</strong>：<code>window.onload</code>  和 <code>$(function)</code> 区别<br>    * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉<br>    * $(function)可以定义多次的。</p><ol start="3"><li>样式控制：css方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $("#div1").css("background-color","red");</span></span><br><span class="line">$(<span class="string">"#div1"</span>).css(<span class="string">"backgroundColor"</span>,<span class="string">"pink"</span>);</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="基础过滤器"><a href="#基础过滤器" class="headerlink" title="基础过滤器"></a>基础过滤器</h4></li><li><code>:first</code><br> 用法: <code>$(&quot;tr:first&quot;)</code> ;   返回值:  单个元素的组成的集合<br> 说明: 匹配找到的第一个元素</li><li><code>:last</code><br> 用法: <code>$(&quot;tr:last&quot;)</code>;  返回值  集合元素<br> 说明: 匹配找到的最后一个元素，与 <code>:first</code> 相对应</li><li><code>:not(selector)</code><br> 用法: <code>$(&quot;input:not(:checked)&quot;)</code>; 返回值:  集合元素<br> 说明: 去除所有与给定选择器匹配的元素。有点类似于「非」，意思是没有被选中的 input (当 input 的<code>type=&quot;checkbox&quot;</code>).</li><li><code>:even</code><br> 用法: <code>$(&quot;tr:even&quot;)</code> ;  返回值:  集合元素<br> 说明: 匹配所有索引值为偶数的元素，从 0 开始计数。js的数组都是从0开始计数的。例如要选择table中的行，因为是从0开始计数，所以 table 中的第一个 tr 就为偶数0.</li><li><code>:odd</code><br>用法: <code>$(&quot;tr:odd&quot;)</code>; 返回值 : 集合元素<br>说明: 匹配所有索引值为奇数的元素，和<code>:even</code>对应，从 0 开始计数.</li><li><code>:eq(index)</code><br> 用法: <code>$(&quot;tr:eq(0)&quot;)</code> ;   返回值:  集合元素<br> 说明: 匹配一个给定索引值的元素<code>.eq(0)</code>就是获取第一个 tr 元素。括号里面的是索引值，不是元素排列数</li><li><code>:gt(index)</code><br> 用法: <code>$(&quot;tr:gt(0)&quot;)</code>;   返回值 : 集合元素<br> 说明: 匹配所有大于给定索引值的元素.</li><li><code>:lt(index)</code><br> 用法: <code>$(&quot;tr:lt(2)&quot;)</code> ;   返回值 : 集合元素<br> 说明: 匹配所有小于给定索引值的元素.</li><li><code>:header(固定写法)</code><br> 用法: <code>$(&quot;:header&quot;).css(&quot;background&quot;， “#EEE&quot;)</code>;    返回值 : 集合元素<br> 说明: 获得标题（h1~h6）元素，固定写法</li><li><code>:animated(固定写法)</code> ;  返回值 : 集合元素<br>说明: 匹配所有正在执行动画效果的元素</li></ol><h4 id="内容过滤器"><a href="#内容过滤器" class="headerlink" title="内容过滤器"></a>内容过滤器</h4><ol><li><code>:contains(text)</code><br> 用法: <code>$(&quot;div:contains(&#39;John&#39;)&quot;)</code>  ;  返回值 : 集合元素<br> 说明: 匹配包含给定文本的元素。这个选择器比较有用，当我们要选择的不是dom标签元素时，它就派上了用场了，它的作用是查找被标签「围」起来的文本内容是否符合指定的内容</li><li><code>:empty</code><br> 用法: <code>$(&quot;td:empty&quot;)</code> ;  返回值 : 集合元素<br> 说明: 匹配所有不包含子元素或者文本的空元素</li><li><code>:has(selector)</code><br> 用法: <code>$(&quot;div:has(p)&quot;).addClass(&quot;test&quot;)</code> ;  返回值 : 集合元素<br> 说明: 匹配含有选择器所匹配的元素的元素。这个解释需要好好琢磨，但是一旦看了使用的例子就完全清楚了，就是给所有包含 p 元素的 div标签加上<code>class=&quot;test&quot;</code></li><li><code>:parent</code><br> 用法:<code>$(&quot;td:parent&quot;)</code> ; 返回值 : 集合元素<br> 说明: 匹配含有子元素或者文本的元素。注意:这里是<code>:parent</code>，可不是<code>.parent</code>。与上面的<code>:empty</code>形成反义</li></ol><h4 id="可见度过滤器"><a href="#可见度过滤器" class="headerlink" title="可见度过滤器"></a>可见度过滤器</h4><ol><li><code>:hidden</code><br> 用法: <code>$(&quot;tr:hidden&quot;)</code> ; 返回值 : 集合元素<br> 说明: 匹配所有的不可见元素，input 元素的 type 属性为 <code>hidden</code> 的话也会被匹配到；意思是 CSS 中<code>display:none</code>和<code>input type=&quot;hidden&quot;</code>的都会被匹配到。同样，要彻底分清楚冒号<code>:</code>点号<code>.</code>和逗号<code>，</code>的区别</li><li><code>:visible</code><br> 用法: <code>$(&quot;tr:visible&quot;)</code>;  返回值 : 集合元素<br> 说明: 匹配所有的可见元素</li></ol><h4 id="属性过滤器"><a href="#属性过滤器" class="headerlink" title="属性过滤器"></a>属性过滤器</h4><ol><li><code>[attribute]</code><br> 用法: <code>$(&quot;div[id]&quot;)</code> ;  返回值 : 集合元素<br> 说明: 匹配包含给定属性的元素。例如：选取所有带 id 属性的 div 标签</li><li><code>[attribute=value]</code><br> 用法: <code>$(&quot;input[name=&#39;newsletter&#39;]“).attr(&quot;checked&quot;， true);</code>   ; 返回值 : 集合元素<br> 说明: 匹配给定的属性是某个特定值的元素。例如：选取所有 name 属性是 newsletter 的 input 元素.</li><li><code>[attribute!=value]</code><br> 用法: <code>$(&quot;input[name!=&#39;newsletter&#39;]&quot;).attr(&quot;checked&quot;， true);</code> ;   返回值 : 集合元素<br> 说明: 匹配所有不含有指定的属性，或者属性不等于特定值的元素。此选择器等价于<code>:not([attr=value])</code>，要匹配含有特定属性但不等于特定值的元素，请使用<code>[attr]:not([attr=value])</code>。之前看到的 <code>:not</code> 派上了用场</li><li><code>[attribute^=value]</code><br> 用法: <code>$(&quot;input[name^=&#39;news&#39;]&quot;)</code> ; 返回值 : 集合元素<br> 说明: 匹配给定的属性是以某些值开始的元素</li><li><code>[attribute$=value]</code><br> 用法: <code>$(&quot;input[name$=&#39;letter&#39;]&quot;)</code> ; 返回值 : 集合元素<br> 说明: 匹配给定的属性是以某些值结尾的元素</li><li><code>[attribute*=value]</code><br> 用法: <code>$(&quot;input[name*=&#39;man&#39;]&quot;)</code> ;  返回值 : 集合元素<br> 说明: 匹配给定的属性是以包含某些值的元素</li><li><code>[attributeFilter1][attributeFilter2][attributeFilterN]</code><br> 用法: <code>$(&quot;input[id][name$=&#39;man&#39;]&quot;)</code> ; 返回值 : 集合元素<br> 说明: 复合属性选择器，需要同时满足多个条件时使用；又是一个组合，这种情况实际使用的时候很常用。这个例子中选择的是所有含有 id 属性，并且它的 name 属性是以 man 结尾的元素。</li></ol><h4 id="子元素过滤器"><a href="#子元素过滤器" class="headerlink" title="子元素过滤器"></a>子元素过滤器</h4><ol><li><p><code>:nth-child(index/even/odd/equation)</code><br> 用法: <code>$(&quot;ul li:nth-child(2)&quot;)</code>   返回值 : 集合元素<br> 说明: 匹配其父元素下的第N个子或奇偶元素。这个选择器和之前说的基础过滤(Basic Filters)中的 <code>eq()</code> 有些类似，不同的地方就是：前者是从 0 开始，后者是从 1 开始。</p></li><li><p><code>:first-child</code><br> 用法: <code>$(&quot;ul li:first-child&quot;)</code>;   返回值 : 集合元素<br> 说明: 匹配第一个子元素；<code>:first</code> 只匹配一个元素，而此选择符将为每个父元素匹配一个子元素，这里需要<strong>特别</strong>的记忆下区别</p></li><li><p><code>:last-child</code><br> 用法: <code>$(&quot;ul li:last-child&quot;)</code>  ;    返回值 : 集合元素<br> 说明: 匹配最后一个子元素；<code>:last</code>只匹配一个元素，而此选择符将为每个父元素匹配一个子元素</p></li></ol><ol start="4"><li><code>:only-child</code><br> 用法: <code>$(&quot;ul li:only-child&quot;)</code> ;  返回值 : 集合元素<br> 说明: 如果某个元素是父元素中唯一的子元素，那将会被匹配；如果父元素中含有其他元素，那将不会被匹配；意思就是:只有一个子元素的才会被匹配</li></ol><h4 id="表单对象属性过滤器"><a href="#表单对象属性过滤器" class="headerlink" title="表单对象属性过滤器"></a>表单对象属性过滤器</h4><ol><li><code>:enabled</code><br> 用法: <code>$(&quot;input:enabled&quot;)</code> ;   返回值 : 集合元素<br> 说明: 匹配所有可用元素；意思是查找所有input中不带有<code>disabled=&quot;disabled&quot;</code>的input；不为disabled，当然就为enabled</li><li><code>:disabled</code><br> 用法: <code>$(&quot;input:disabled&quot;)</code>  ;  返回值 : 集合元素<br> 说明: 匹配所有不可用元素。与上面的那个是相对应的</li><li><code>:checked</code><br> 用法: <code>$(&quot;input:checked&quot;)</code> ;  返回值 : 集合元素<br> 说明: 匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</li><li><code>:selected</code><br> 用法: <code>$(&quot;select option:selected&quot;)</code> ;  返回值 : 集合元素<br> 说明: 匹配所有选中的option元素</li></ol><h4 id="表单过滤器"><a href="#表单过滤器" class="headerlink" title="表单过滤器"></a>表单过滤器</h4><ol><li><code>:input</code><br> 用法:<code>$(&quot;:input&quot;)</code> ;   返回值 : 集合元素<br> 说明:匹配所有 input， textarea， select 和 button 元素</li><li><code>:text</code><br> 用法: <code>$(&quot;:text&quot;)</code> ;  返回值 : 集合元素<br> 说明: 匹配所有的单行文本框</li><li><code>:password</code><br> 用法: <code>$(&quot;:password&quot;)</code> ; 返回值 : 集合元素<br> 说明: 匹配所有密码框</li><li><code>:radio</code><br> 用法: <code>$(&quot;:radio&quot;)</code> ; 返回值 : 集合元素<br> 说明: 匹配所有单选按钮</li><li><code>:checkbox</code><br> 用法: <code>$(&quot;:checkbox&quot;)</code> ; 返回值 : 集合元素<br> 说明: 匹配所有复选框</li><li><code>:submit</code><br> 用法: <code>$(&quot;:submit&quot;)</code> ;   返回值 : 集合元素<br> 说明: 匹配所有提交按钮</li></ol><h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><h4 id="外部插入"><a href="#外部插入" class="headerlink" title="外部插入"></a>外部插入</h4><p><code>after(content)</code> :在每个匹配的元素之后插入内容<br><code>before(content)</code>:在每个匹配的元素之前插入内容<br><code>insertAfter(content)</code>:把所有匹配的元素插入到另一个、指定的元素元素集合的后面<br><code>insertBefore(content)</code> :把所有匹配的元素插入到另一个、指定的元素元素集合的前面</p><h4 id="内部插入"><a href="#内部插入" class="headerlink" title="内部插入"></a>内部插入</h4><p><code>append(content)</code> :向每个匹配的元素的内部的结尾处追加内容<br><code>appendTo(content)</code> :将每个匹配的元素追加到指定的元素中的内部结尾处<br><code>prepend(content)</code>:向每个匹配的元素的内部的开始处插入内容<br><code>prependTo(content)</code> :将每个匹配的元素插入到指定的元素内部的开始处</p><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>选择器/过滤器 可以实现查找节点<br><code>attr(&quot;name&quot;)</code><br><code>attr(&quot;name&quot;，&quot;value&quot;)</code><br><code>removeAttr(&quot;name&quot;)</code></p><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>使用 jQuery 的工厂函数 <code>$()</code>:<code>$(html)</code>; 会根据传入的 html 标记字符串创建一个 DOM 对象， 并把这个 DOM 对象包装成一个 jQuery 对象返回</p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p><code>remove()</code>: 从 DOM 中删除所有匹配的元素， 传入的参数用于根据 jQuery 表达式来筛选元素；当某个节点用 remove() 方法删除后， 该节点所包含的所有后代节点将被同时删，这个方法的返回值是一个指向已被删除的节点的引用<br><code>empty()</code>: 清空节点 – 清空元素中的所有后代节点(不包含属性节点)</p><h4 id="内容操作"><a href="#内容操作" class="headerlink" title="内容操作"></a>内容操作</h4><ol><li><code>html()</code>: 获取/设置元素的标签体内容   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">font</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>  --&gt; <span class="tag">&lt;<span class="name">font</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><code>text()</code>: 获取/设置元素的标签体纯文本内容  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">font</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> --&gt; 内容</span><br></pre></td></tr></table></figure></li><li><code>val()</code>： 获取/设置元素的value属性值</li></ol><h4 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h4><ul><li>通用属性操作</li></ul><ol><li><code>attr()</code>: 获取/设置元素的属性</li><li><code>removeAttr()</code>:删除属性</li><li><code>prop()</code>:获取/设置元素的属性</li><li><code>removeProp()</code>:删除属性</li></ol><p><strong>[注意]</strong>：attr 和 prop 区别？<br>    1. 如果操作的是元素的固有属性，则建议使用prop<br>    2. 如果操作的是元素自定义的属性，则建议使用attr</p><ul><li>对class属性操作</li></ul><ol><li><code>addClass()</code>:添加class属性值</li><li><code>removeClass()</code>:删除class属性值</li><li><code>toggleClass()</code>:切换class属性<br> <code>toggleClass(&quot;one&quot;)</code>: 判断如果元素对象上存在class=”one”，则将属性值one删除掉。  如果元素对象上不存在 class=”one”，则添加</li><li><code>css()</code>:获取css样式</li></ol><h2 id="JQuery对象和JS对象区别与转换"><a href="#JQuery对象和JS对象区别与转换" class="headerlink" title="JQuery对象和JS对象区别与转换"></a>JQuery对象和JS对象区别与转换</h2><ol><li>JQuery对象在操作时，更加方便。</li><li>JQuery对象和js对象方法不通用的。</li><li>两者相互转换<ul><li>jq – &gt; js : <code>jq对象[索引]</code> 或者 <code>jq对象.get(索引)</code></li><li>js – &gt; jq : <code>$(js对象)</code></li></ul></li></ol><h2 id="jQuery-高级"><a href="#jQuery-高级" class="headerlink" title="jQuery 高级"></a>jQuery 高级</h2><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>三种方式显示和隐藏元素动画</p><ol><li>默认显示和隐藏方式</li></ol><ul><li><p><code>show([speed,[easing],[fn]])</code></p><pre><code>参数：1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;    * swing：动画执行时效果是 先慢，中间快，最后又慢    * linear：动画执行时速度是匀速的3. fn：在动画完成时执行的函数，每个元素执行一次。</code></pre></li><li><p><code>hide([speed,[easing],[fn]])</code></p></li><li><p><code>toggle([speed],[easing],[fn])</code></p></li></ul><ol start="2"><li>滑动显示和隐藏方式</li></ol><ul><li><code>slideDown([speed],[easing],[fn])</code></li><li><code>slideUp([speed,[easing],[fn]])</code></li><li><code>slideToggle([speed],[easing],[fn])</code></li></ul><ol start="3"><li>淡入淡出显示和隐藏方式</li></ol><ul><li><code>fadeIn([speed],[easing],[fn])</code></li><li><code>fadeOut([speed],[easing],[fn])</code></li><li><code>fadeToggle([speed,[easing],[fn]])</code></li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol><li>javascript的遍历方式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化值;循环结束条件;步长)</span><br></pre></td></tr></table></figure></li><li>jquery的遍历方式</li></ol><ul><li><code>jq对象.each(callback)</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 语法：</span><br><span class="line">    jquery对象.each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;&#125;);</span><br><span class="line">        * index:就是元素在集合中的索引</span><br><span class="line">        * element：就是集合中的每一个元素对象</span><br><span class="line"></span><br><span class="line">        * <span class="keyword">this</span>：集合中的每一个元素对象</span><br><span class="line"><span class="number">2.</span> 回调函数返回值：</span><br><span class="line">    * <span class="literal">true</span>:如果当前<span class="function"><span class="keyword">function</span>返回为<span class="title">false</span>，则结束循环(<span class="params">break</span>)。</span></span><br><span class="line"><span class="function">    * <span class="title">false</span>:如果当前<span class="title">function</span>返回为<span class="title">true</span>，则结束本次循环，继续下次循环(<span class="params">continue</span>)</span></span><br></pre></td></tr></table></figure></li><li><code>$.each(object, [callback])</code></li><li><code>for..of</code> jquery 3.0 版本之后提供的方式<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素对象 <span class="keyword">of</span> 容器对象)</span><br></pre></td></tr></table></figure></li></ul><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ol><li>jquery标准的绑定方式<br><code>jq对象.事件方法(回调函数)</code>；<br>注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。<br> <code>表单对象.submit()</code>;//让表单提交</li><li>on绑定事件/off解除绑定<br><code>jq对象.on(&quot;事件名称&quot;,回调函数)</code><br><code>jq对象.off(&quot;事件名称&quot;)</code><br> 如果off方法不传递任何参数，则将组件上的所有事件全部解绑</li><li>事件切换：toggle<br><code>jq对象.toggle(fn1,fn2...)</code><br> 当单击jq对象对应的组件后，会执行fn1；第二次点击会执行fn2…..</li></ol><p><strong>注意</strong>：1.9版本 <code>.toggle()</code> 方法删除，jQuery Migrate（迁移）插件可以恢复此功能。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../js/jquery-migrate-1.0.0.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>增强JQuery的功能，实现方式如下：</p><ol><li><code>$.fn.extend(object)</code><br> 增强通过Jquery获取的对象的功能 <code>$(&quot;#id&quot;)</code></li><li><code>$.extend(object)</code><br> 增强JQeury对象自身的功能 <code>$/jQuery</code></li></ol><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p> AJAX 即“Asynchronous JavaScript and XML”（异步JavaScript和XML)，AJAX 并非缩写词，而是由Jesse James Gaiiett创造的名词，是指一种创建交互式网页应用的网页开发技术。WEB2.0</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用javascript向服务器提出请求并处理响应而不阻塞用户，核心对象 XMLHTTPRequest。通过这个对象，JavaScript 可在不重载页面的情况与Web服务器交换数据。<br>AJAX 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。<br>AJAX 可使因特网应用程序更小、更快、更友好。</p><h2 id="XMLHttpRequest-对象初始化"><a href="#XMLHttpRequest-对象初始化" class="headerlink" title="XMLHttpRequest 对象初始化"></a>XMLHttpRequest 对象初始化</h2><p>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xmlHttp;   </span><br><span class="line">    <span class="keyword">try</span>&#123; <span class="comment">// Firefox, Opera 8.0+, Safari</span></span><br><span class="line">            xmlHttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;<span class="comment">// Internet Explorer</span></span><br><span class="line">                xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xmlHttp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XMLHttpRequest对象方法"><a href="#XMLHttpRequest对象方法" class="headerlink" title="XMLHttpRequest对象方法"></a>XMLHttpRequest对象方法</h3><p> <img src="/images/tech/web-ajax-xmlhttprequest-method.png" alt="method"></p><h2 id="服务器端向客户端进行响应-注册监听"><a href="#服务器端向客户端进行响应-注册监听" class="headerlink" title="服务器端向客户端进行响应(注册监听)"></a>服务器端向客户端进行响应(注册监听)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status==<span class="number">200</span>||xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> data = xhr.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readyState</code>： 属性表示Ajax请求的当前状态。它的值用数字代表。<br>               0 代表未初始化。 还没有调用 open 方法<br>               1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用<br>               2 代表已加载完毕。send 已被调用。请求已经开始<br>               3 代表交互中。服务器正在发送响应<br>               4 代表完成。响应发送完毕</p><p><code>xhr.status</code>：<br>    常用状态码及其含义：<br>    404 没找到页面(not found)<br>    403 禁止访问(forbidden)<br>    500 内部服务器出错(internal service error)<br>    200 一切正常(ok)<br>    304 没有被修改(not modified)（服务器返回304状态，表示源文件没有被修改)</p><p><code>xhr.responseText</code>： 服务器发回的响应结果，字符串<br><code>xhr.responseXML</code>： 服务器返回的响应结果，XML对象</p><h2 id="客户端与服务器端建立连接"><a href="#客户端与服务器端建立连接" class="headerlink" title="客户端与服务器端建立连接"></a>客户端与服务器端建立连接</h2><p>使用的是 XMLHttpRequest 对象的 <code>open(method, url, asynch)</code>方法</p><ul><li><code>method</code>：请求类型，类似 “GET”或”POST”的字符串。</li><li><code>url</code>：路径字符串，指向你所请求的服务器上的那个文件。可以是绝对路径或相对路径。</li><li><code>asynch</code>：表示请求是否要异步传输，默认值为true(异步)。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">"GET"</span>,<span class="string">"../testServlet?timeStamp="</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()+<span class="string">"&amp;c=19"</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="客户端向服务器端发送请求"><a href="#客户端向服务器端发送请求" class="headerlink" title="客户端向服务器端发送请求"></a>客户端向服务器端发送请求</h2><p>使用的是 XMLHttpRequest 对象的<code>send()</code>方法</p><ul><li>如果请求类型是GET方式的话，使用send()方法发送请求数据，服务器端接收不到</li><li>该步骤不能被省略，只能写成<code>xhr.send(null)</code>;</li></ul><h3 id="GET方式"><a href="#GET方式" class="headerlink" title="GET方式"></a>GET方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="POST方式"><a href="#POST方式" class="headerlink" title="POST方式"></a>POST方式</h3><p>如果请求类型是POST的话，需要设置请求首部信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/json"</span>);</span><br><span class="line">xhr.send(<span class="string">"a=7&amp;b=8"</span>);</span><br></pre></td></tr></table></figure><h2 id="jQuery实现Ajax"><a href="#jQuery实现Ajax" class="headerlink" title="jQuery实现Ajax"></a>jQuery实现Ajax</h2><h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h3><ul><li>语法：<code>$.ajax({键值对});</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用$.ajax()发送异步请求</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"ajaxServlet1111"</span> , <span class="comment">// 请求路径</span></span><br><span class="line">    type:<span class="string">"POST"</span> , <span class="comment">//请求方式</span></span><br><span class="line">    <span class="comment">//data: "username=jack&amp;age=23",//请求参数</span></span><br><span class="line">    data:&#123;<span class="string">"username"</span>:<span class="string">"jack"</span>,<span class="string">"age"</span>:<span class="number">23</span>&#125;,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        alert(data);</span><br><span class="line">    &#125;,<span class="comment">//响应成功后的回调函数</span></span><br><span class="line">    error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"出错啦..."</span>)</span><br><span class="line">    &#125;,<span class="comment">//表示如果请求响应出现错误，会执行的回调函数</span></span><br><span class="line"></span><br><span class="line">    dataType:<span class="string">"text"</span><span class="comment">//设置接受到的响应数据的格式</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="$.get()"></a>$.get()</h3></li><li>语法：<code>$.get(url, [data], [callback], [type])</code></li><li>参数：<pre><code>* url：请求路径* data：请求参数* callback：回调函数* type：响应结果的类型</code></pre></li></ul><h3 id="post"><a href="#post" class="headerlink" title="$.post()"></a>$.post()</h3><ul><li>语法：<code>$.post(url, [data], [callback], [type])</code></li><li>参数：<pre><code>* url：请求路径* data：请求参数* callback：回调函数* type：响应结果的类型</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jQuery&quot;&gt;&lt;a href=&quot;#jQuery&quot; class=&quot;headerlink&quot; title=&quot;jQuery&quot;&gt;&lt;/a&gt;jQuery&lt;/h1&gt;&lt;p&gt;jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScr
      
    
    </summary>
    
    
      <category term="Web" scheme="https://hashcode.cn/categories/Web/"/>
    
    
      <category term="Web，jQuery，Ajax" scheme="https://hashcode.cn/tags/Web%EF%BC%8CjQuery%EF%BC%8CAjax/"/>
    
  </entry>
  
  <entry>
    <title>JSP/EL/JSTL 快速入门</title>
    <link href="https://hashcode.cn/2019/07/08/web-jsp-el-jstl-base/"/>
    <id>https://hashcode.cn/2019/07/08/web-jsp-el-jstl-base/</id>
    <published>2019-07-08T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>JSP(JavaServer Pages) 是一种动态页面技术，它实现了Html语法中的java扩展（以 <code>&lt;%, %&gt;</code>形式）。JSP 与 Servlet 一样，是在服务器端执行的。通常返回给客户端的就是一个 HTML 文本，因此客户端只要有浏览器就能浏览。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用于配置 JSP 页面，导入资源文件</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2%&gt;</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>page：用于标识和配置 JSP 页面</li></ol><ul><li>contentType：类似于response.setContentType()，用于设置响应体的mime类型及字符集，设置当前 JSP 页面编码</li><li>import：导入包</li><li>errorPage：当前页面发生异常后，会跳转到指定的错误页面，例如 404 等</li><li>isErrorPage：标识当前是否是错误页面，参数：true（可以使用内置对象 exception），页面默认值是 false</li><li>session：用于指定当前页面是否可以使用session</li><li>pageEncoding：解决乱码问题(在低级工具中声明)</li></ul><ol start="2"><li>include：包含页面，导入其他页面资源文件：<br>&lt;%@ include file=”index.jsp”%&gt;</li><li>taglib：用于导入第三方资源<br>&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;%&gt;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;%&gt;</a> 其中prefix支持自定义</li></ol><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ol><li>JSP脚本表达式 ：       &lt;%=  java表达式 %&gt;</li><li>JSP脚本片断   ：       &lt;% 任意多的java语句 %&gt;</li><li>JSP声明      ：       &lt;%!  java代码 %&gt;</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="html注释"><a href="#html注释" class="headerlink" title="html注释"></a>html注释</h3><pre><code>`&lt;!-- --&gt;`:只能注释 html 代码片段</code></pre><h3 id="jsp注释"><a href="#jsp注释" class="headerlink" title="jsp注释"></a>jsp注释</h3><p>推荐使用：<code>&lt;%-- --%&gt;</code>：可以注释所有</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul><li>在jsp页面中不需要创建，直接使用的对象, 一共有9个：<pre><code>变量名                    真实类型                        作用</code></pre><ul><li><code>pageContext</code>                PageContext                    当前页面共享数据，还可以获取其他八个内置对象</li><li><code>request</code>                    HttpServletRequest            一次请求访问的多个资源(转发)</li><li><code>session</code>                    HttpSession                    一次会话的多个请求间</li><li><code>application</code>                ServletContext                所有用户间共享数据</li><li><code>response</code>                    HttpServletResponse            响应对象</li><li><code>page</code>                        Object                        当前页面(Servlet)的对象  this</li><li><code>out</code>                        JspWriter                    输出对象，数据输出到页面上</li><li><code>config</code>                    ServletConfig                Servlet的配置对象</li><li><code>exception</code>                    Throwable                    异常对象</li></ul></li></ul><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><ul><li><code>out</code><br>相当于<code>response.getWriter()</code>获取到的输入流，内置单独的缓冲区<br>[ buffer=”none | <code>8kb</code> | sizekb” ] out隐式对象所使用的缓冲区的大小<br>[ autoFlush=”true | false” ] out隐式对象是否自动刷新缓冲区，默认为true，不需要更改</li><li><code>pageContext</code><br>代表当前 JSP 的运行环境<br>生命周期:  随着 JSP 页面打开而创建,随着关闭而销毁.<br>用处:     在整个 JSP 页面中共享数据</li></ul><ol><li>可以作为入口对象获取其他八大隐示对象的引用<br> <code>getException</code><br> <code>getPage</code><br> <code>getRequest</code><br> <code>getRespons</code><br> <code>getServletConfig</code><br> <code>getServletContext</code> 方法返回 application 隐式对象<br> <code>getSession</code><br> <code>getOut</code><br> <strong><strong><strong>___</strong></strong></strong>返回的都是本类型的隐示对象</li></ol><ol start="2"><li><p>首先是一个域对象，作为入口操作四大作用域中的数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletContext(application域) &gt; Session(session域)  &gt; request(request域) &gt;pageContext(page域)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来操作page域中的属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(java.lang.String?name,java.lang.Object?value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> java.lang.Object?<span class="title">getAttribute</span><span class="params">(java.lang.String?name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>?<span class="title">removeAttribute</span><span class="params">(java.lang.String?name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用来操作四大作用域中任意域中的属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(java.lang.String?name, java.lang.Object?value,<span class="keyword">int</span>?scope)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> java.lang.Object?<span class="title">getAttribute</span><span class="params">(java.lang.String?name,<span class="keyword">int</span>?scope)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>?<span class="title">removeAttribute</span><span class="params">(java.lang.String?name,<span class="keyword">int</span>?scope)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">PageContext.APPLICATION_SCOPE</span></span><br><span class="line"><span class="function">PageContext.SESSION_SCOPE</span></span><br><span class="line"><span class="function">PageContext.REQUEST_SCOPE</span></span><br><span class="line"><span class="function">PageContext.PAGE_SCOPE</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong>： 四大作用域什么时候用:<br> 如果一个数据只在当前jsp页面中使用，存入page域。<br> 如果一个数据，在Servlet中处理好后，请求转发到其他serlvet或jsp使用此数据，放入request域。<br> 如果一个数据，我当前要用，过一会我自己还要用。存入session。<br> 如果一个数据，我当前要用，过一会其他人也要用。存入application域。</p><hr><p> <code>findAttribute</code>: (此方法用来查找各个域中的属性)<br> 从最小的域开始向最大的域搜索(page,request,session,application),找到就则返回该值,找完四大作用域找不到则返回null</p></li></ol><ol start="3"><li>提交了快捷方法,实现请求转发和请求包含<pre><code>pageContext.forward(&quot;&quot;);pageContext.include(&quot;&quot;);</code></pre></li></ol><h1 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h1><p>EL(Expression Language) 表达式语言,用于获取数据、执行运算、操作web中隐含对象、调用java函数</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>${标识符}</code><br>EL表达式语句在执行时，会调用<code>pageContext.findAttribute</code>方法，用标识符为关键字，分别从 <code>page</code> 、 <code>request</code> 、 <code>session</code> 、<code>application</code> 四个域 中查找相应的对象，找到则返回相应对象，找不到则返回<code>””</code> （注意：不是null，而是空字符串）。<br><strong>「经验」</strong>：只要标识符中没有逻辑错误，语法错误，就不会报错，<code>${a}</code>的结果是个<code>“”</code>字符串。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li>算数运算符： + - * /(<code>div</code>) %(<code>mod</code>)</li><li>比较运算符： &gt; &lt; &gt;= &lt;= == !=</li><li>逻辑运算符： &amp;&amp;(<code>and</code>) ||(<code>or</code>) !(<code>not</code>)</li><li>空运算符： <code>empty</code><ul><li>功能：用于判断字符串、集合、数组对象是否为 null 或者长度是否为 0</li><li><code>${empty list}</code>:判断字符串、集合、数组对象是否为 null 或者长度为 0</li><li><code>${not empty str}</code>:表示判断字符串、集合、数组对象是否不为 null 并且 长度 &gt; 0</li></ul></li></ol><h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>EL 表达式只能从域对象中获取值</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><ol><li><p><code>${域名称.键名}</code>：从指定域中获取指定键的值</p><ul><li>域名称：<ol><li>pageScope        –&gt; pageContext</li><li>requestScope     –&gt; request</li><li>sessionScope     –&gt; session</li><li>applicationScope –&gt; application（ServletContext）</li></ol></li><li>[举例]：在request域中存储了name=zhangsan</li><li>[获取]：${requestScope.name}</li></ul></li><li><p><code>${键名}</code>：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p></li><li><p>获取对象、List 集合、Map 集合的值</p><ol><li><p>对象：<code>${域名称.键名.属性名}</code></p><ul><li>本质上会去调用对象的 <code>getter</code> 方法</li></ul></li><li><p>List集合：<code>${域名称.键名[索引]}</code></p></li><li><p>Map集合：</p><ul><li><code>${域名称.键名.key名称}</code></li><li><code>${域名称.键名[&quot;key名称&quot;]}</code></li></ul></li></ol><ol start="4"><li>调用java方法                       <ul><li>调用的方法必须是静态方法</li><li>在开发中一般是直接使用(taglib)指令导入相关的包,j2ee5.0以上已经内置</li></ul></li></ol></li></ol><h3 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h3><p>EL 表达式中有11个内置对象：不需要定义直接在 EL 中可以直接使用</p><p><img src="/images/tech/web-scope-object-hidden01" alt="域对象"><br><img src="/images/tech/web-scope-object-hidden02" alt="6个隐式对象"></p><p><strong>「注意」</strong></p><ul><li>只能用来获取集合数组中的数据不能用来遍历</li><li>只能用来获取数据不能用来设置数据</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="getParameter-和-getAttribute-区别-？"><a href="#getParameter-和-getAttribute-区别-？" class="headerlink" title="getParameter 和 getAttribute 区别 ？"></a>getParameter 和 getAttribute 区别 ？</h3><p>=====================================================<br>getParameter 获得 HTTP中请求参数的值</p><p>getAttribute 获得服务器端各种数据范围的值 <code>request.getAttribute</code> 获得request数据范围的值</p><ul><li>值在服务器端通过 <code>request.setAttribute</code> 保存的</li></ul><p>getParameter 获得客户端提交的数据，getAttribute 服务器内部传递的数据</p><h3 id="getParameter-与-getParamValues-的区别"><a href="#getParameter-与-getParamValues-的区别" class="headerlink" title="getParameter() 与 getParamValues() 的区别 ?"></a>getParameter() 与 getParamValues() 的区别 ?</h3><p>=====================================================<br>param 、paramValues 用户获得请求参数的值<br><code>${param.name}</code> ==== request.getParameter(“name”);<br><code>${paramValues.name}</code> ===== request.getParameterValues(“name”);</p><h3 id="getHeader-与-getHeaderValues-区别"><a href="#getHeader-与-getHeaderValues-区别" class="headerlink" title="getHeader() 与 getHeaderValues() 区别 ?"></a>getHeader() 与 getHeaderValues() 区别 ?</h3><p>=====================================================<br>header、headerValues 获得请求头信息的数据<br><code>${header[&quot;user-agent&quot;]}</code> ========== request.getHeader(“user-agent”);<br><code>${headerValues[&quot;user-agent&quot;]}</code> ============= request.getHeaders(“user-agent”);</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>=====================================================<br>用来在开发中快速获得 cookie 的值  ——- 是一个Map&lt;String,Cookie&gt; //保持的value是对象<br><code>${cookie.name.value}</code> 获得指定名称的cookie的value值</p><h3 id="initParam"><a href="#initParam" class="headerlink" title="initParam"></a>initParam</h3><p>=====================================================<br>用来快速读取 ServletContext 的全局初始化参数<br><code>${initParam.name}</code> ===================== getServletContext().getInitParameter(“name”);</p><ul><li><context-param> 配置全局参数</li></ul><h3 id="最常使用"><a href="#最常使用" class="headerlink" title="最常使用"></a>最常使用</h3><p>=====================================================<br>cookie   ———– <code>${cookie.name.value}</code> 这里 name 是 cookie 的 name 值<br>pageContext ————- <code>${pageContext.request.contextPath}</code> ==== pageContext.getRequest().getContextPath() 返回 <code>/virtual-directory</code></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 编写一个链接 --&gt;</span><br><span class="line">&lt;a href="/virtual-directory/el/1.jsp"&gt;link&lt;/a&gt;</span><br><span class="line">&lt;!-- 使用EL 获得工程名 --&gt;</span><br><span class="line">&lt;a href="$&#123;pageContext.request.contextPath &#125;/el/1.jsp"&gt;link&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>快速获得ip ： <code>${pageContext.request.remoteAddr}</code><br>注册信息的回调 ： <code>${param.username}</code> ，因为提交的信息还保存在request里</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>JSP 默认支持 EL 表达式的。如果要忽略 EL 表达式则使用以下方法：</p><ol><li>JSP 中 page 指令中：<code>isELIgnored=&quot;true&quot;</code>忽略当前jsp页面中所有的 EL 表达式</li><li><code>\${表达式}</code> ：忽略当前这个el表达式</li></ol><h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><p>JSTL (JavaServer Pages Tag Library) 是 JSP 标准标签库，是由 Apache 组织提供的开源的免费的 JSP &lt;标签&gt;，用于简化和替换 JSP 页面上的Java 代码</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>导入jstl相关jar包</li><li>引入标签库：taglib指令：  &lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;%&gt;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;%&gt;</a></li><li>使用标签</li></ol><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><p><code>&lt;c:out&gt;</code> 标签用于输出一段文本内容到<code>pageContext</code>对象当前保存的<code>out</code>对象中。</p><p><code>&lt;c:set&gt;</code>标签用于把某一个对象存在指定的域范围内，或者设置 Web 域中的 java.util.Map 类型的属性对象或 JavaBean 类型的属性对象的属性。</p><p><code>&lt;c:remove&gt;</code>标签用于删除各种 Web 域中的属性</p><p><code>&lt;c:catch&gt;</code>标签用于捕获嵌套在标签体中的内容抛出的异常，其语法格式如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:catch [var="varName"]&gt;nested actions&lt;/c:catch&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;c:if test=“”&gt;</code> 标签可以构造简单的<code>if-then</code>结构的条件表达式</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"条件,可以写el表达式"</span>&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;c:choose&gt;</code> 标签用于指定多个条件选择的组合边界，它必须与<code>&lt;c:when&gt;</code>和<code>&lt;c:otherwise&gt;</code>标签一起使用。<br>                    使用<code>&lt;c:choose&gt;</code>，<code>&lt;c:when&gt;</code>和<code>&lt;c:otherwise&gt;</code>三个标签，可以构造类似 <code>if-else if-else</code> 的复杂条件判断结构。</p><p><code>&lt;c:forEach&gt;</code> 标签用于对一个集合对象中的元素进行循环迭代操作，或者按指定的次数重复迭代执行标签体中的内容。语法格式如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似于java中的fori</span></span><br><span class="line">&lt;c:forEach begin=<span class="string">"1"</span> end=<span class="string">"length"</span> <span class="keyword">var</span>=<span class="string">"i"</span>&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"><span class="comment">//类似于java中的foreach</span></span><br><span class="line">&lt;c:forEach items=<span class="string">"strs"</span> <span class="keyword">var</span>=<span class="string">"str"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;c:forTokens&gt;</code>用来浏览一字符串中所有的成员，其成员是由定义符号所分隔的</p><p><code>&lt;c:param&gt;</code>标签  在JSP页面进行URL的相关操作时，经常要在 URL 地址后面附加一些参数。<br>                <code>&lt;c:param&gt;</code>标签可以嵌套在<code>&lt;c:import&gt;</code>、<code>&lt;c:url&gt;</code>或<code>&lt;c:redirect&gt;</code>标签内，为这些标签所使用的URL地址附加参数。</p><p><code>&lt;c:import&gt;</code> 标签,实现 include 操作</p><p><code>&lt;c:url&gt;</code> 标签用于在 JSP 页面中构造一个 URL 地址，其主要目的是实现 URL 重写。URL 重写就是将会话标识号以参数形式附加在 URL 地址后面</p><p><code>&lt;c:redirect&gt;</code> 标签用于实现请求重定向</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSP&quot;&gt;&lt;a href=&quot;#JSP&quot; class=&quot;headerlink&quot; title=&quot;JSP&quot;&gt;&lt;/a&gt;JSP&lt;/h1&gt;&lt;p&gt;JSP(JavaServer Pages) 是一种动态页面技术，它实现了Html语法中的java扩展（以 &lt;code&gt;&amp;lt;%, 
      
    
    </summary>
    
    
      <category term="Web" scheme="https://hashcode.cn/categories/Web/"/>
    
    
      <category term="Web" scheme="https://hashcode.cn/tags/Web/"/>
    
      <category term="JSP" scheme="https://hashcode.cn/tags/JSP/"/>
    
      <category term="EL" scheme="https://hashcode.cn/tags/EL/"/>
    
      <category term="JSTL" scheme="https://hashcode.cn/tags/JSTL/"/>
    
  </entry>
  
  <entry>
    <title>Cookie &amp; Session 基础</title>
    <link href="https://hashcode.cn/2019/07/02/web-cookie-session/"/>
    <id>https://hashcode.cn/2019/07/02/web-cookie-session/</id>
    <published>2019-07-02T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><p>为了实现某一个需求，浏览器和服务器之间会产生多次的请求和响应；从打开浏览器访问服务器开始，到访问服务器结束关闭浏览器，之间的多次请求和响应称为：「浏览器和服务器之间的一次会话」<br>「一次会话」：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>在一次会话的范围内的多次请求间，共享数据</p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><ol><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ol><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据(可以叫做浏览器缓存）</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>客户端会话技术，将数据保存到客户端</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>创建Cookie对象，绑定数据<br> new Cookie(String name, String value) </li><li>发送Cookie对象<br> response.addCookie(Cookie cookie) </li><li>获取Cookie，拿到数据<br> Cookie[]  request.getCookies()  </li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>基于响应头set-cookie和请求头cookie实现</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>new cookie(“key”,”value”);</li><li>setPath(path);</li><li>setMaxAge(time);</li><li>response.addCookie(cookie);</li></ol><p>删除cookie的时候只需要覆盖同路径，同名，只要存活时间(serMaxAge(0))设置为0就可以</p><h2 id="一次可不可以发送多个cookie"><a href="#一次可不可以发送多个cookie" class="headerlink" title="一次可不可以发送多个cookie?"></a>一次可不可以发送多个cookie?</h2><p>可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</p><h2 id="cookie在浏览器中保存多长时间？"><a href="#cookie在浏览器中保存多长时间？" class="headerlink" title="cookie在浏览器中保存多长时间？"></a>cookie在浏览器中保存多长时间？</h2><ul><li>默认情况下，当浏览器关闭后，Cookie数据被销毁</li><li>持久化存储： <code>setMaxAge(int seconds)</code><ul><li>正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</li><li>负数：默认值</li><li>零：删除cookie信息</li></ul></li></ul><h2 id="cookie能不能存中文？"><a href="#cookie能不能存中文？" class="headerlink" title="cookie能不能存中文？"></a>cookie能不能存中文？</h2><ul><li>在tomcat 8 之前 cookie中不能直接存储中文数据。需要将中文数据转码—一般采用URL编码(%E3)</li><li>在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析</li></ul><h2 id="cookie共享问题？"><a href="#cookie共享问题？" class="headerlink" title="cookie共享问题？"></a>cookie共享问题？</h2><ol><li>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？</li></ol><ul><li>默认情况下cookie不能共享</li><li><code>setPath(String path)</code>:设置 cookie 的获取范围。默认情况下，设置当前的虚拟目录</li><li>如果要共享，则可以将 path 设置为<code>/</code></li></ul><ol start="2"><li>不同的 tomcat 服务器间 cookie 共享问题？</li></ol><ul><li><code>setDomain(String path)</code>：如果设置一级域名相同，那么多个服务器之间 cookie 可以共享</li><li><code>setDomain(&quot;.baidu.com&quot;)</code>：那么tieba.baidu.com和news.baidu.com中 cookie 可以共享</li></ul><h2 id="Cookie的特点和作用"><a href="#Cookie的特点和作用" class="headerlink" title="Cookie的特点和作用"></a>Cookie的特点和作用</h2><ol><li>cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie 的大小有限制<code>(4kb)</code> 以及 对同一个域名下的总cookie数量也有限制(20个)</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>cookie一般用于存出少量的不太敏感的数据</li><li>在不登录的情况下，完成服务器对客户端的身份识别</li><li>eg： 记住上一次访问时间</li></ol><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>获取HttpSession对象：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure></li><li>使用HttpSession对象：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2></li><li>调用<code>request.getSession()</code>;方法时开始创建</li><li>默认是<code>30</code>分钟用户无操作自动销毁</li><li>可以手动销毁</li></ol><h3 id="三种销毁Session对象情况"><a href="#三种销毁Session对象情况" class="headerlink" title="三种销毁Session对象情况"></a>三种销毁Session对象情况</h3><ol><li>不正常关闭服务(正常关闭服务器Session信息会被序列化到硬盘中 保存tomcat/work目录)</li><li>session 对象调用invalidate() 手动销毁Session对象</li><li>session 默认失效时间 30分钟（连续不使用Session对象时间）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//选择性配置修改，在tomcat/conf/web.xml 配置</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">    &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>Session的实现是依赖于Cookie的</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="当客户端关闭后，服务器不关闭，两次获取-session-是否为同一个？"><a href="#当客户端关闭后，服务器不关闭，两次获取-session-是否为同一个？" class="headerlink" title="当客户端关闭后，服务器不关闭，两次获取 session 是否为同一个？"></a>当客户端关闭后，服务器不关闭，两次获取 session 是否为同一个？</h3><ul><li>默认情况下，不是同一个。</li><li>如果需要相同，则可以创建 Cookie,键为 JSESSIONID，设置最大存活时间，让 cookie 持久化保存。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>,session.getId());</span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure></li></ul><h3 id="客户端不关闭，服务器关闭后，两次获取的session是同一个吗？"><a href="#客户端不关闭，服务器关闭后，两次获取的session是同一个吗？" class="headerlink" title="客户端不关闭，服务器关闭后，两次获取的session是同一个吗？"></a>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</h3><ul><li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作</li><li>session的<code>钝化</code>： 在服务器正常关闭之前，将session对象系列化到硬盘上</li><li>session的<code>活化</code>： 在服务器启动后，将session文件转化为内存中的session对象即可。</li></ul><h2 id="session的特点"><a href="#session的特点" class="headerlink" title="session的特点"></a>session的特点</h2><ol><li>session用于存储一次会话的多次请求的数据，存在服务器端</li><li>session可以存储任意类型，任意大小的数据</li></ol><h2 id="解决浏览器禁止cookie的情况-了解即可"><a href="#解决浏览器禁止cookie的情况-了解即可" class="headerlink" title="解决浏览器禁止cookie的情况 (了解即可)"></a>解决浏览器禁止cookie的情况 (了解即可)</h2><p>浏览器无法保存cookie中jsession id ，无法完成Session追踪，通过程序重写URL(携带session的URL)</p><h1 id="小结：session与Cookie的区别"><a href="#小结：session与Cookie的区别" class="headerlink" title="小结：session与Cookie的区别"></a>小结：session与Cookie的区别</h1><ol><li>session存储数据在服务器端，Cookie在客户端</li><li>session没有数据大小限制，Cookie有</li><li>session数据安全，Cookie相对于不安全</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;会话技术&quot;&gt;&lt;a href=&quot;#会话技术&quot; class=&quot;headerlink&quot; title=&quot;会话技术&quot;&gt;&lt;/a&gt;会话技术&lt;/h1&gt;&lt;p&gt;为了实现某一个需求，浏览器和服务器之间会产生多次的请求和响应；从打开浏览器访问服务器开始，到访问服务器结束关闭浏览器，之间的
      
    
    </summary>
    
    
      <category term="Web" scheme="https://hashcode.cn/categories/Web/"/>
    
    
      <category term="Web" scheme="https://hashcode.cn/tags/Web/"/>
    
      <category term="Cookie" scheme="https://hashcode.cn/tags/Cookie/"/>
    
      <category term="Session" scheme="https://hashcode.cn/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 快速入门</title>
    <link href="https://hashcode.cn/2019/06/08/web-javascript-base/"/>
    <id>https://hashcode.cn/2019/06/08/web-javascript-base/</id>
    <published>2019-06-08T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>概念：运行在客户端浏览器中的一门客户端脚本语言。每一个浏览器都有 JavaScript 的解析引擎，不需要编译，直接就可以被浏览器解析执行。<br>功能：可以来增强用户和 html 页面的交互过程，可以来控制 html 元素，让页面有一些动态的效果，增强用户的体验。</p><h2 id="JavaScript-发展史"><a href="#JavaScript-发展史" class="headerlink" title="JavaScript 发展史"></a>JavaScript 发展史</h2><ol><li>1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C- -    ，后来更名为：ScriptEase</li><li>1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript</li><li>1996年，微软抄袭JavaScript开发出jscript语言</li><li>1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。</li></ol><p>「注」：JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)</p><h1 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h1><p>客户端脚本语言的标准</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="与-html-结合方式"><a href="#与-html-结合方式" class="headerlink" title="与 html 结合方式"></a>与 html 结合方式</h3><ol><li>内部js：<br> 定义<code>&lt;script&gt;</code> 标签体内容就是js代码</li><li>外部js：<br> 定义<code>&lt;script&gt;</code> 通过src属性引入外部的js文件</li><li>注意：<ol><li><code>&lt;script&gt;</code> 可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</li><li><code>&lt;script&gt;</code> 可以定义多个。</li></ol></li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>单行注释：//注释内容</li><li>多行注释：<code>/*注释内容*/</code></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>原始数据类型(基本数据类型)：<br><code>number</code>：数字。 整数/小数/ NaN (not a number 一个不是数字的数字类型)<br><code>string</code>：字符串。 字符串  “abc” “a” ‘abc’<br><code>boolean</code>： true 和 false<br><code>null</code>：一个对象为空的占位符<br><code>undefined</code>：未定义。如果一个变量没有给初始化值，则会被默认赋值为 undefined</p></li><li><p>引用数据类型：对象</p></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量：一小块存储数据的内存空间</li><li>Java 语言是强类型语言，而 JavaScript 是弱类型语言。<br>  强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据<br>  弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</li><li>语法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = 初始化值;</span><br></pre></td></tr></table></figure></li><li><code>typeof</code> 运算符：获取变量的类型。<br>  注：<code>null</code>运算后得到的是<code>object</code></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol><li><p>一元运算符：只有一个运算数的运算符，<code>++</code>，<code>--</code> ， <code>+</code>(正号)  </p><ul><li><code>++</code> <code>--</code>： 自增(自减)</li><li><code>+(-)</code>：正负号</li><li>注意：在 js 中，如果运算数不是运算符所要求的类型，那么 js 引擎会自动的将运算数进行类型转换</li></ul></li><li><p>算数运算符：<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> …</p></li><li><p>赋值运算符：<code>=</code> <code>+=</code> <code>-+</code> …</p></li><li><p>比较运算符：<code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code>  <code>===(全等于)</code></p><ol><li>类型相同：按照字典顺序直接比较。按位逐一比较，直到得出大小为止。</li><li>类型不同：先进行类型转换，再比较</li><li><code>===</code>：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回 false</li></ol></li><li><p>逻辑运算符：<code>&amp;&amp;</code>  <code>||</code>  <code>!</code></p></li><li><p>三元运算符：<code>表达式? 值1 : 值2;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> c = a &gt; b ? <span class="number">1</span> : <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>其他类型转 <code>number</code>：</p><ul><li>string 转 number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）</li><li>boolean 转 number：true转为1，false转为0</li></ul></li><li><p>其他类型转 <code>boolean</code>：</p><ol><li>number：0或NaN为假，其他为真</li><li>string：除了空字符串(“”)，其他都是true</li><li>null&amp;undefined：都是false</li><li>对象：所有对象都为true</li></ol></li></ol><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ol><li>if…else…</li><li>switch：在java中，switch语句可以接受的数据类型： byte int shor char。在js中,switch语句可以接受<code>任意</code>的<code>原始</code>数据类型<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)：</span><br><span class="line"> <span class="keyword">case</span> 值：</span><br></pre></td></tr></table></figure>「注」：Java Switch中：枚举(1.5) ,String(1.7)</li><li>while</li><li>do…while</li><li>for</li></ol><h3 id="js特殊语法"><a href="#js特殊语法" class="headerlink" title="js特殊语法"></a>js特殊语法</h3><ol><li>语句以<code>;</code>结尾，如果一行只有一条语句则 <code>;</code>可以省略 (不建议)</li><li>变量的定义使用var关键字，也可以不使用<br> <strong>用</strong>： 定义的变量是<code>局部</code>变量<br> <strong>不用</strong>：定义的变量是<code>全局</code>变量(不建议)</li></ol><h3 id="练习：99乘法表"><a href="#练习：99乘法表" class="headerlink" title="练习：99乘法表"></a>练习：99乘法表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>99乘法表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        td&#123;</span><br><span class="line">            border： 1px solid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"&lt;table  align='center'&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//1.完成基本的for循环嵌套，展示乘法表</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span> ; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(<span class="string">"&lt;tr&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;=i ; j++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">"&lt;td&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//输出  1 * 1 = 1</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(i + <span class="string">" * "</span> + j + <span class="string">" = "</span> + ( i*j) +<span class="string">"&amp;nbsp;&amp;nbsp;&amp;nbsp;"</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">"&lt;/td&gt;"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">            /*//输出换行</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);*<span class="regexp">/</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(<span class="string">"&lt;/tr&gt;"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">//2.完成表格嵌套</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"&lt;/table&gt;"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h2><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>函数(方法)对象</p><ol><li>创建：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//第一种方式</span></span><br><span class="line">    <span class="keyword">var</span> fun = <span class="keyword">new</span> <span class="built_in">Function</span>(形式参数列表,方法体);  <span class="comment">//不建议使用</span></span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> 方法名称(<span class="params">形式参数列表</span>)</span>&#123;</span><br><span class="line">            方法体</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种方式</span></span><br><span class="line">    <span class="keyword">var</span> 方法名 = <span class="function"><span class="keyword">function</span>(<span class="params">形式参数列表</span>)</span>&#123;</span><br><span class="line">            方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>属性：<br> <code>length</code>： 代表形参的个数</li><li>特点：<ol><li>方法定义是，形参的类型不用写,返回值类型也不写。</li><li>方法是一个对象，如果定义名称相同的方法，会覆盖</li><li>在js中，方法的调用只与方法的名称有关，和参数列表无关</li><li>在方法声明中有一个隐藏的内置对象（数组）：<code>arguments</code>，封装所有的实际参数</li></ol></li><li>调用：<br> 方法名称(实际参数列表);</li></ol><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>数组对象</p><ol><li>创建：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(元素列表);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(默认长度);</span><br><span class="line"><span class="keyword">var</span> arr = [元素列表];</span><br></pre></td></tr></table></figure></li><li>方法<br> <code>join(参数)</code>：将数组中的元素按照指定的分隔符拼接为字符串<br> <code>push()</code>：向数组的末尾添加一个或更多元素，并返回新的长度。</li><li>属性<br> <code>length</code>：数组的长度</li><li>特点：js中，数组<code>元素的类型</code>是可变的,<code>长度</code>是可变的。</li></ol><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>日期对象</p><ol><li><p>创建：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></li><li><p>方法：<br> <code>toLocaleString()</code>：返回当前date对象对应的时间本地字符串格式<br> <code>getTime()</code>：获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p></li></ol><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>数学对象</p><ol><li>创建：Math对象不用创建，直接使用。  <code>Math.方法名();</code></li><li>方法：<br><code>random()</code>：返回 0 ~ 1 之间的随机数。 含0不含1<br><code>ceil(x)</code>：对数进行上舍入。<br><code>floor(x)</code>：对数进行下舍入。<br><code>round(x)</code>：把数四舍五入为最接近的整数。</li><li>属性： PI , …</li></ol><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><ul><li>正则表达式，定义字符串的组成规则。<ol><li>单个字符：<code>[]</code><br> 如： [a] [ab] [a-zA-Z0-9_]<br> 特殊符号代表特殊含义的单个字符：<br> <code>\d</code>：单个数字字符 [0-9]<br> <code>\w</code>：单个单词字符[a-zA-Z0-9_]</li><li>量词符号：<br> <code>?</code>：表示出现0次或1次<br> <code>*</code>：表示出现0次或多次<br> <code>+</code>：出现1次或多次<br> <code>{m,n}</code>：表示 m&lt;= 数量 &lt;= n<pre><code>* m如果缺省： {,n}：最多n次* n如果缺省：{m,} 最少m次</code></pre></li><li>开始结束符号<br> <code>^</code>：开始<br> <code>$</code>：结束</li></ol></li><li>正则对象：<ol><li>创建<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"正则表达式"</span>);</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>;</span><br></pre></td></tr></table></figure></li><li>方法<br><code>test(参数)</code>：验证指定的字符串是否符合正则定义的规范    </li></ol></li></ul><h3 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h3><ol><li><p>特点：全局对象，这个 Global 中封装的方法不需要对象就可以直接调用。  <code>方法名();</code></p></li><li><p>方法：<br> <code>encodeURI()</code>：url编码<br> <code>decodeURI(</code>)：url解码</p><p> <code>encodeURIComponent()</code>：url编码,编码的字符更多<br> <code>decodeURIComponent()</code>：url解码</p><p> <code>parseInt()</code>：将字符串转为数字</p><pre><code>* 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number</code></pre><p> <code>isNaN()</code>：判断一个值是否是NaN</p><pre><code>* NaN六亲不认，连自己都不认。NaN参与的==比较全部为false</code></pre><p> <code>eval()</code>：将 JavaScript 字符串，并把它作为脚本代码来执行。</p></li><li><p>URL编码：XXXX =  %E4%BX%A2%Ea%95%BA%E5%92%AD%E3%A2%A3</p></li></ol><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>概念</strong>：某些组件被执行了某些操作后，触发某些代码的执行。    </p><ul><li>事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了</li><li>事件源：组件。如： 按钮 文本输入框…</li><li>监听器：代码。</li><li>注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</li></ul><h2 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h2><h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><ol><li><code>onclick</code> ：单击事件</li><li><code>ondblclick</code> ：双击事件<br>eg：通过 js 获取元素对象，指定事件属性，设置一个函数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img id=<span class="string">"light"</span> src=<span class="string">"img/off.gif"</span>  onclick=<span class="string">"fun();"</span>&gt;</span><br><span class="line">    &lt;img id=<span class="string">"light2"</span> src=<span class="string">"img/off.gif"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'被点击'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'被点击2'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.获取light2对象</span></span><br><span class="line">        <span class="keyword">var</span> light2 = <span class="built_in">document</span>.getElementById(<span class="string">"light2"</span>);</span><br><span class="line">        <span class="comment">//2.绑定事件</span></span><br><span class="line">        light2.onclick = fun2;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3></li><li><code>onblur</code> ：失去焦点</li><li><code>onfocus</code> ：元素获得焦点。</li></ol><h3 id="加载事件"><a href="#加载事件" class="headerlink" title="加载事件"></a>加载事件</h3><ol><li><code>onload</code> ：一张页面或一幅图像完成加载。</li></ol><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ol><li><code>onmousedown</code>    鼠标按钮被按下。</li><li><code>onmouseup</code>    鼠标按键被松开。</li><li><code>onmousemove</code>    鼠标被移动。</li><li><code>onmouseover</code>    鼠标移到某元素之上。</li><li><code>onmouseout</code>    鼠标从某元素移开。</li></ol><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ol><li><code>onkeydown</code>    某个键盘按键被按下。    </li><li><code>onkeyup</code>        某个键盘按键被松开。</li><li><code>onkeypress</code>    某个键盘按键被按下并松开。</li></ol><h3 id="选择和改变"><a href="#选择和改变" class="headerlink" title="选择和改变"></a>选择和改变</h3><ol><li><code>onchange</code>    域的内容被改变。</li><li><code>onselect</code>    文本被选中。</li></ol><h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><ol><li><code>onsubmit</code>    确认按钮被点击。</li><li><code>onreset</code>    重置按钮被点击。</li></ol><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Browser Object Model 浏览器对象模型，将浏览器的各个组成部分封装成对象。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li><code>Window</code> ：窗口对象</li><li><code>Navigator</code> ：浏览器对象</li><li><code>Screen</code> ：显示器屏幕对象</li><li><code>History</code> ：历史记录对象</li><li><code>Location</code> ：地址栏对象</li></ul><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><ol><li><p>创建：直接可以<code>window.方法名()</code>，window 关键字可省略</p></li><li><p>方法</p><ol><li>与弹出框有关的方法：<br><code>alert()</code>    显示带有一段消息和一个确认按钮的警告框。<br><code>confirm()</code>    显示带有一段消息以及确认按钮和取消按钮的对话框，有返回值<br><code>prompt()</code>    显示可提示用户输入的对话框。返回值：获取用户输入的值</li><li>与打开关闭有关的方法：<br><code>close()</code>    关闭浏览器窗口。谁调用我 ，我关谁<br><code>open()</code>    打开一个新的浏览器窗口，返回新的Window对象</li><li>与定时器有关的方式<br><code>setTimeout()</code>    在指定的毫秒数后调用函数或计算表达式。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">    1. js代码或者方法对象</span><br><span class="line">    2. 毫秒值</span><br><span class="line">返回值：唯一标识，用于取消定时器</span><br></pre></td></tr></table></figure><code>clearTimeout()</code>    取消由 setTimeout() 方法设置的 timeout。<br><code>setInterval()</code>    按照指定的周期（以毫秒计）来调用函数或计算表达式。<br><code>clearInterval()</code>    取消由 setInterval() 设置的 timeout。</li></ol></li><li><p>属性</p></li></ol><ul><li>获取其他BOM对象：<br>  <code>history</code><br>  <code>location</code><br>  <code>Navigator</code><br>  <code>Screen</code></li><li>获取DOM对象<br>  <code>document</code></li></ul><ol start="4"><li>特点<br>Window 对象不需要创建可以直接使用 <code>window</code> 使用。 <code>window.方法名();</code><br>window 引用可以省略。 <code>方法名();</code></li></ol><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><ol><li><p>创建(获取)</p><ol><li><code>window.location</code></li><li><code>location</code></li></ol></li><li><p>方法：<br><code>reload()</code>    重新加载当前文档。刷新</p></li><li><p>属性<br><code>href</code>    设置或返回完整的 URL。</p></li></ol><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><ol><li><p>创建(获取)</p><ol><li><code>window.history</code></li><li><code>history</code></li></ol></li><li><p>方法<br><code>back()</code>    加载 history 列表中的前一个 URL。<br><code>forward()</code>    加载 history 列表中的下一个 URL。<br><code>go(参数)</code>    加载 history 列表中的某个具体页面。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">    正数：前进几个历史记录</span><br><span class="line">    负数：后退几个历史记录</span><br></pre></td></tr></table></figure></li><li><p>属性<br> <code>length</code> 返回当前窗口历史列表中的 URL 数量。</p></li></ol><h3 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h3><h3 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h3><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>Document Object Model 文档对象模型，将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行 CRUD 的动态操作。<br><img src="/images/tech/web-dom-tree-elem.png" alt="dom-tree-elem"></p><h2 id="DOM分类"><a href="#DOM分类" class="headerlink" title="DOM分类"></a>DOM分类</h2><p>W3C DOM 标准被分为 3 个不同的部分</p><h3 id="核心-DOM"><a href="#核心-DOM" class="headerlink" title="核心 DOM"></a>核心 DOM</h3><p>针对任何结构化文档的标准模型</p><h4 id="Document：文档对象"><a href="#Document：文档对象" class="headerlink" title="Document：文档对象"></a>Document：文档对象</h4><ol><li>创建(获取)：在html dom 模型中可以使用 window 对象来获取<ol><li><code>window.document</code></li><li><code>document</code></li></ol></li><li>方法：</li></ol><ul><li>获取 Element 对象：<ol><li><code>getElementById()</code>    ： 根据id属性值获取元素对象。id属性值一般唯一</li><li><code>getElementsByTagName()</code>：根据元素名称获取元素对象们。返回值是一个数组</li><li><code>getElementsByClassName()</code>：根据Class属性值获取元素对象们。返回值是一个数组</li><li><code>getElementsByName()</code>： 根据name属性值获取元素对象们。返回值是一个数组</li></ol></li><li>创建其他DOM对象：<br>  <code>createAttribute(name)</code><br>  <code>createComment()</code><br>  <code>createElement()</code><br> <code>createTextNode()</code></li></ul><h4 id="Element：元素对象"><a href="#Element：元素对象" class="headerlink" title="Element：元素对象"></a>Element：元素对象</h4><ol><li>获取/创建：通过 document 来获取和创建</li><li>方法：<ol><li><code>removeAttribute()</code>：删除属性</li><li><code>setAttribute()</code>：设置属性</li></ol></li></ol><h4 id="Node：节点对象"><a href="#Node：节点对象" class="headerlink" title="Node：节点对象"></a>Node：节点对象</h4><p>Node节点对象是其他5个的父对象。</p><ul><li>特点：所有 dom 对象都可以被认为是一个节点</li><li>方法：<ul><li><code>appendChild()</code>：向节点的子节点列表的结尾添加新的子节点。</li><li><code>removeChild()</code>    ：删除（并返回）当前节点的指定子节点。</li><li><code>replaceChild()</code>：用新节点替换一个子节点。</li></ul></li><li>属性：<ul><li><code>parentNode</code> 返回节点的父节点。</li></ul></li></ul><h4 id="Attribute：属性对象"><a href="#Attribute：属性对象" class="headerlink" title="Attribute：属性对象"></a>Attribute：属性对象</h4><h4 id="Text：文本对象"><a href="#Text：文本对象" class="headerlink" title="Text：文本对象"></a>Text：文本对象</h4><h4 id="Comment-注释对象"><a href="#Comment-注释对象" class="headerlink" title="Comment:注释对象"></a>Comment:注释对象</h4><h3 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h3><p>针对 HTML 文档的标准模型</p><ol><li>标签体的设置和获取： <code>innerHTML</code></li><li>使用 html 元素对象的属性</li><li>控制元素样式<ol><li>使用元素的 <code>style</code> 属性来设置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改样式方式1</span></span><br><span class="line">div1.style.border = <span class="string">"1px solid red"</span>;</span><br><span class="line">div1.style.width = <span class="string">"200px"</span>;</span><br><span class="line"><span class="comment">//font-size--&gt; fontSize</span></span><br><span class="line">div1.style.fontSize = <span class="string">"20px"</span>;</span><br></pre></td></tr></table></figure></li><li>提前定义好类选择器的样式，通过元素的 <code>className</code> 属性来设置其class属性值。</li></ol></li></ol><h3 id="XML-DOM"><a href="#XML-DOM" class="headerlink" title="XML DOM"></a>XML DOM</h3><ul><li>针对 XML 文档的标准模型</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>js语法的使用基本类似java，只需在使用时随手查阅文档即可。要把握好 DOM 和 BOM 的区别，DOM管理浏览器的内容对象，BOM管理浏览器的控件对象。而 BOM 控制(获取) DOM。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript&quot;&gt;&lt;a href=&quot;#JavaScript&quot; class=&quot;headerlink&quot; title=&quot;JavaScript&quot;&gt;&lt;/a&gt;JavaScript&lt;/h1&gt;&lt;p&gt;概念：运行在客户端浏览器中的一门客户端脚本语言。每一个浏览器都有 JavaS
      
    
    </summary>
    
    
      <category term="Web" scheme="https://hashcode.cn/categories/Web/"/>
    
    
      <category term="Web" scheme="https://hashcode.cn/tags/Web/"/>
    
      <category term="JavaScript" scheme="https://hashcode.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>游泳手记</title>
    <link href="https://hashcode.cn/2019/06/01/daily-2019-0601/"/>
    <id>https://hashcode.cn/2019/06/01/daily-2019-0601/</id>
    <published>2019-06-01T11:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蛙泳"><a href="#蛙泳" class="headerlink" title="蛙泳"></a>蛙泳</h1><h2 id="漂"><a href="#漂" class="headerlink" title="漂"></a>漂</h2><p>手臂放在耳朵后面伸直，自然向前漂</p><h2 id="滑行"><a href="#滑行" class="headerlink" title="滑行"></a>滑行</h2><p>手臂伸直，脑袋钻进水里，双脚向后蹬墙，感受水中滑行。</p><h2 id="蹬腿"><a href="#蹬腿" class="headerlink" title="蹬腿"></a>蹬腿</h2><p>四个动作：</p><h3 id="收"><a href="#收" class="headerlink" title="收"></a>收</h3><p>双腿并拢，向后往屁股方向收，注意脚腕用力</p><h3 id="翻"><a href="#翻" class="headerlink" title="翻"></a>翻</h3><p>把双腿分开，用力保持收的姿势和脚腕</p><h3 id="蹬夹"><a href="#蹬夹" class="headerlink" title="蹬夹"></a>蹬夹</h3><p>用力向后蹬腿的同时夹拢双腿</p><h2 id="换气"><a href="#换气" class="headerlink" title="换气"></a>换气</h2><p>3个动作：<br>慢慢抬头的过程中就开始用嘴巴出气，出水后发出啪的一声，然后大力用嘴巴吸气，再次进入水中</p><h2 id="蹬腿换气结合"><a href="#蹬腿换气结合" class="headerlink" title="蹬腿换气结合"></a>蹬腿换气结合</h2><p>换气，低头后蹬腿，然后滑行2-3秒。重复以上</p><h2 id="划手-换气-蹬腿"><a href="#划手-换气-蹬腿" class="headerlink" title="划手+换气+蹬腿"></a>划手+换气+蹬腿</h2><p>手分开至双肩宽或比肩稍宽，用小臂向下划水同时慢慢抬头换气，小臂划至胸口位置时收小臂从中心位置向前探出同时低头1秒在进行蹬腿，蹬腿后漂2-3秒再重复以上</p><h2 id="蹬腿口诀"><a href="#蹬腿口诀" class="headerlink" title="蹬腿口诀"></a>蹬腿口诀</h2><p>边收边分满收腿，向外翻脚对准水，向后弧形蹬夹腿，两腿伸直漂一会儿</p><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>划手腿不动，收手又收腿，先伸胳膊后蹬腿，手腿伸直漂一会儿<br>简称：划收伸蹬</p><h1 id="踩水"><a href="#踩水" class="headerlink" title="踩水"></a>踩水</h1><h2 id="抬头扶板蛙泳腿"><a href="#抬头扶板蛙泳腿" class="headerlink" title="抬头扶板蛙泳腿"></a>抬头扶板蛙泳腿</h2><p>双手扶着浮板的前端，抬头(下巴露出水面即可)蹬腿(收翻等夹)，直到可以蹬25m</p><h2 id="深水抱浮板"><a href="#深水抱浮板" class="headerlink" title="深水抱浮板"></a>深水抱浮板</h2><p>手抱紧浮板在胸前，腿部姿势像是坐小板凳，腿置于上身的前面蹬蛙泳腿，保持下巴在水面上</p><h2 id="浅水抬头蛙泳"><a href="#浅水抬头蛙泳" class="headerlink" title="浅水抬头蛙泳"></a>浅水抬头蛙泳</h2><p>下巴露出水面，手和脚(收翻蹬)，重复做蛙泳的动作前进</p><h1 id="潜水"><a href="#潜水" class="headerlink" title="潜水"></a>潜水</h1><p>头朝下，身体呈倒栽的姿势，使用蛙泳的姿势潜行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蛙泳&quot;&gt;&lt;a href=&quot;#蛙泳&quot; class=&quot;headerlink&quot; title=&quot;蛙泳&quot;&gt;&lt;/a&gt;蛙泳&lt;/h1&gt;&lt;h2 id=&quot;漂&quot;&gt;&lt;a href=&quot;#漂&quot; class=&quot;headerlink&quot; title=&quot;漂&quot;&gt;&lt;/a&gt;漂&lt;/h2&gt;&lt;p&gt;手臂放在耳朵后
      
    
    </summary>
    
    
      <category term="Daily" scheme="https://hashcode.cn/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://hashcode.cn/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>HTML 和 CSS 快速入门</title>
    <link href="https://hashcode.cn/2019/05/27/web-html-css-base/"/>
    <id>https://hashcode.cn/2019/05/27/web-html-css-base/</id>
    <published>2019-05-27T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>hyper text markup language 超文本标记语言，是最基础的网页开发语言。网页文件后缀名以<code>.html</code>/<code>.htm</code>结束。</p><h2 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h2><h3 id="文件标签"><a href="#文件标签" class="headerlink" title="文件标签"></a>文件标签</h3><p><code>&lt;!DOCTYPE html&gt;</code>：html5 中定义该文档类型是html文档<br><code>&lt;html&gt;</code>：html 文档的根标签<br><code>&lt;head&gt;</code>：头标签，用于指定 html 文档的一些属性，引入外部的资源。<br><code>&lt;title&gt;</code>：标题标签<br><code>&lt;body&gt;</code>：体标签</p><h3 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h3><p><code>注释</code>：<code>&lt;!-- 注释内容 --&gt;</code><br><code>&lt;h1&gt; to &lt;h6&gt;</code>：标题标签，字体大小逐渐递增<br><code>&lt;p&gt;</code>：段落标签<br><code>&lt;br&gt;</code>：换行标签<br><code>&lt;hr&gt;</code>：水平线,属性：color,width,size,align(center,left,right)<br><code>&lt;b&gt;</code>：字体加粗<br><code>&lt;i&gt;</code>：字体斜体<br><code>&lt;font&gt;</code>：字体标签,属性：color,size,face<br><code>&lt;center&gt;</code>：文本居中</p><h3 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h3><p><code>color</code>:<br>    1. 英文单词：red,green,blue<br>    2. rgb(值1,值2,值3)：值的取值范围：0<del>255。 如rgb(0,0,255)<br>    3. #值1值2值3：值的范围：00</del>FF之间。如 #00FF00<br><code>width</code>:<br>    1. 数值 width = ‘20’，数值的单位默认是px像素<br>    2. 数值%：占比相对于父元素的比例。</p><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><p><code>&lt;img&gt;</code>：图片标签，属性：src,alt,align,width,height<br><code>相对路径</code>：以<code>.</code>开头的路径，eg：<code>./</code>代表当前路径，<code>../</code>代表上一级目录</p><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><code>&lt;ol&gt;</code>：有序列表外层标签<br><code>&lt;ul&gt;</code>：无序列表外层标签<br><code>&lt;li&gt;</code>：条目标签，包含属性 type</p><h3 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h3><p><code>&lt;a&gt;</code>：超链接标签<br>属性：<code>href</code>：访问资源的 URL ,<code>target</code>：打开资源的方式(<code>_self</code>默认值,<code>_blank</code>)</p><h3 id="div和span"><a href="#div和span" class="headerlink" title="div和span"></a>div和span</h3><p><code>&lt;div&gt;</code>：每一个 div 占满一行，块级标签<br><code>&lt;span&gt;</code>：文本信息在一行展示，行内标签</p><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>语义化标签是 html5 之后出现的新特性，目的是为了提高程序的可读性<br><code>&lt;header&gt;</code>：页眉<br><code>&lt;footer&gt;</code>：页脚</p><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><code>&lt;table&gt;</code>：定义表格标签<br>属性：<br>width,border,bgcolor,align<br>cellpadding：单元格内容与单元格的距离<br>cellspacing：定义单元格之间的距离，如果指定为0，则单元格线会合并为一条<br><code>&lt;tr&gt;</code>：定义行<br><code>&lt;td&gt;</code>：定义单元格<br><code>&lt;th&gt;</code>：定义表头单元格<br><code>&lt;caption&gt;</code>：表格标题<br><code>&lt;thead&gt;</code>：表格中表头内容，类似语义化标签，目的为增强代码可读性<br><code>&lt;tbody&gt;</code>：表格表体内容<br><code>&lt;tfoot&gt;</code>：表格脚注</p><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>用户采集用户输入的数据，和服务器进行交互。</p><h3 id="表单体标签"><a href="#表单体标签" class="headerlink" title="表单体标签"></a>表单体标签</h3><p><code>&lt;form&gt;</code>：可以定义一个范围，范围代表采集用户数据的范围。<br>属性：<br>     action<br>     method：请求方式有7种，一般使用 get，post<br>     name：(不指定无法提交表单项中的数据)</p><h3 id="表单项标签"><a href="#表单项标签" class="headerlink" title="表单项标签"></a>表单项标签</h3><p><code>&lt;input&gt;</code>：可以通过 <code>type</code> 属性改变元素展示的样式。<br><code>type</code>属性值：<br>    text：文本<br>    password：密码<br>    radio(<code>value</code>属性指定提交的值,<code>checked</code>指定默认值),<br>    checkbox(<code>value</code>属性指定提交的值,<code>checke</code>d指定默认值),<br>    placeholder：提示文字<br>    file：选择文件框<br>    hidden：隐藏域，用于提交一些信息。<br>    submit：提交按钮<br>    button：普通按钮<br>    image：图片提交按钮，<code>src</code>属性选择图片路径<br>    color：取色器<br>    date：日期选择<br>    datetime-local：带时分日期选择<br>    email：邮箱<br>    number：数字选择<br><code>&lt;label&gt;</code>：指定输入项的文字描述信息，其<code>for</code>属性一般会和 input 的 id 属性对应。这样点击 label 后 input 则会获取到焦点。<br><code>&lt;select&gt;</code>：下拉列表<br><code>&lt;option&gt;</code>：下拉列表中的子选项,<code>value</code>属性用于指定提交的值<br><code>&lt;textarea&gt;</code>：多行输入框，属性<code>rows</code>，<code>cols</code>用于指定行数和每行显示的字符数。</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Cascading Style Sheets 层叠样式表，多个样式可作用在同一个 html 元素上，同时生效。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>在标签内使用<code>style</code>属性指定 css 代码<br>eg：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:red;"</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><p>在<code>head</code>标签内，定义<code>style</code>标签 style 标签体内容就是 css 代码<br>eg：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><p>1.定义 css 资源文件<br>2.在<code>head</code>标签内，定义<code>link</code>标签，引入外部的资源文件<br>eg：<br>.css文件</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"> <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.html文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/a.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h3><p>格式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    属性名1:属性值1;</span><br><span class="line">    属性名1:属性值1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：每一对属性需要使用<code>;</code>隔开，最后一对属性可以不加<code>;</code></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>筛选具有相似特征的元素</p><ul><li>基础选择器</li></ul><ol><li>id选择器：选择具体的 id 属性值的元素，建议在 html 页面中 id 值唯一；语法：<code>#id属性值{}</code></li><li>元素选择器：选择具有相同标签名称的元素；语法：<code>标签名称{}</code>，注意 id 选择器优先级高于元素选择器</li><li>类选择器：选择具有相同的 class 属性值的元素<code>.class属性值{}</code>，注意类选择器优先级高于元素选择器，低于 id 选择器</li></ol><ul><li>扩展选择器</li></ul><ol><li>选择素有元素；语法：<code>*{}</code></li><li>并集选择器；语法：<code>选择器1,选择器2{}</code></li><li>子选择器：筛选选择器1元素下的选择器2元素；语法：<code>选择器1 选择器2{}</code></li><li>父选择器：筛选选择器2的父元素选择器1；语法：<code>选择器1 &gt; 选择器2{}</code></li><li>属性选择器：选择元素名称,属性名=属性值的元素；语法：<code>元素名称[属性名=&quot;属性值&quot;]{}</code></li><li>伪类选择器：选择一些元素具有的状态；语法：<code>元素:状态{}</code></li></ol><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>字体、文本<br><code>font-size</code>：字体大小<br><code>color</code>：文本颜色<br><code>text-align</code>：对齐方式<br><code>line-height</code>：行高</li><li>背景<br><code>background</code>：背景，属性<code>url</code>可以指定图片路径</li><li>边框<br><code>border</code>：设置边框，复合属性</li><li>尺寸<br><code>width</code>：宽度<br><code>height</code>：高度</li><li>盒子模型：控制布局<br><code>margin</code>：外边距<br><code>padding</code>：内边距，默认情况下调整内边距会影响整个盒子的大小，这时可设置<code>box-sizing:border-box;</code>确定盒子的指定宽高为最终大小<br><code>float</code>：left,right</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;p&gt;hyper text markup language 超文本标记语言，是最基础的网页开发语言。网页文件后缀名以&lt;code&gt;.
      
    
    </summary>
    
    
      <category term="Web" scheme="https://hashcode.cn/categories/Web/"/>
    
    
      <category term="Web" scheme="https://hashcode.cn/tags/Web/"/>
    
      <category term="HTML" scheme="https://hashcode.cn/tags/HTML/"/>
    
      <category term="CSS" scheme="https://hashcode.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JDBC 基本使用</title>
    <link href="https://hashcode.cn/2019/05/25/java-jdbc/"/>
    <id>https://hashcode.cn/2019/05/25/java-jdbc/</id>
    <published>2019-05-25T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.802Z</updated>
    
    <content type="html"><![CDATA[<p>JDBC：Java DataBase Connection，简言就是使用 Java 语言操作数据库。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db2"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">String sql = <span class="string">"update account set balance = 500 where id = 1"</span>;</span><br><span class="line"><span class="keyword">int</span> count = statement.executeUpdate(sql);</span><br><span class="line">System.out.println(count);</span><br><span class="line">connection.close();</span><br><span class="line">statement.close();</span><br></pre></td></tr></table></figure><h2 id="详解各个类"><a href="#详解各个类" class="headerlink" title="详解各个类"></a>详解各个类</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><ol><li>驱动管理对象</li></ol><p>注册驱动：通知数据库该使用哪一个数据库驱动的jar</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册给定的驱动程序 DriverManeger</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(Driver driver)</span></span></span><br><span class="line"><span class="function"><span class="comment">//写代码时使用</span></span></span><br><span class="line"><span class="function">Class.<span class="title">forName</span><span class="params">(<span class="string">"com.mysql.jdbc.Driver"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>通过查看源码发现：在 <code>com.mysql.jdbc.Driver</code> 类中存在静态代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        java.mysql.DriverManeger.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>获取数据库连接</li></ol><ul><li>方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Connection get <span class="title">Connection</span><span class="params">(String url, String user, String password)</span></span></span><br></pre></td></tr></table></figure></li><li>参数：<br><code>url</code>：指定连接的路径<pre><code>语法：jdbc:mysql//ip地址:端口号/数据库名称例子：jdbc:mysql//localhost:3306/db2细节：如果连接的是本机mysql服务器，并且默认端口为3306，则url可以简写为：jdbc:mysql:///数据库名称</code></pre><code>user</code>:用户名<br><code>password</code>:密码</li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>数据库连接对象</p><ol><li>获取执行sql对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Statement <span class="title">createStatement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span></span></span><br></pre></td></tr></table></figure></li><li>管理事务<br>开启事务：<code>setAutoCommit(boolean autoCommit)</code>，调用该方法设置参数为false开启事务。<br>提交事务：<code>commit()</code><br>回滚事务：<code>rollback()</code></li></ol><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>用于执行sql的对象</p><ol><li><code>boolean execute(String sql)</code>，可以执行任意的sql</li><li><code>int executeUpdate(String sql)</code>，执行DML(insert、update、delete)语句、DDL(create、alter、drop)语句；返回值是影响的行数，可以用来判断是否执行成功。</li><li><code>ResultSet executeQuery(String sql)</code>：执行DQL（select）语句</li></ol><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><p>结果集对象<br><code>boolean next()</code>:游标向下移动一行，判断当前行是否是末尾（是否有数据），如果是则返回false，如果不是则返回true<br><code>getXxx(参数)</code>:获取数据，Xxx代表数据类型，如：getString()、getInt()；参数可以使用列编号也可以使用列名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">double</span> banlance = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>用于执行安全执行sql的对象，防止注入问题</p><ol><li>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全问题。</li><li>解决SQL注入问题：使用<code>PreparedStatement</code>对象来解决</li><li>预编译的SQL：参数使用<code>?</code>作为占位符</li><li>使用<ul><li>获取执行SQL语句的对象： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement Connection.prepareStatement(String sql)</span><br></pre></td></tr></table></figure></li><li>给<code>?</code>赋值：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setXxx(参数<span class="number">1</span>，参数<span class="number">2</span>)，</span><br><span class="line">    参数<span class="number">1</span>：? 位置的编号，从<span class="number">1</span>开始</span><br><span class="line">    参数<span class="number">2</span>：? 的值</span><br></pre></td></tr></table></figure></li></ul></li><li>注意：<code>PreparedStatement</code> 可以防止sql注入，且效率更高。</li></ol><h2 id="JDBC-控制事务"><a href="#JDBC-控制事务" class="headerlink" title="JDBC 控制事务"></a>JDBC 控制事务</h2><p>使用<code>Connection</code>对象来管理事务<br>开启事务：<code>setAutoCommit(boolean autoCommit)</code>，参数设置为false，即开启事务。一般在sql执行之前开启事务<br>提交事务：<code>commit()</code>，当所有 sql 执行完提交事务<br>回滚事务：<code>rollback()</code>，在 catch 中回滚事务<br>设置回滚点：<code>setSavePoin()</code><br>回滚到回滚点：<code>rollback(sp)</code></p><h2 id="JDBC-连接池"><a href="#JDBC-连接池" class="headerlink" title="JDBC 连接池"></a>JDBC 连接池</h2><p>频繁向系统申请连接数据库的操作是一个相对耗时的操作。为了提高效率并节省资源，引入数据库连接池的概念，而 JDBC 连接池其实就是一个用于存放数据库连接的容器（集合）；当系统初始化完毕之后，容器就会被创建，容器中会申请一些连接对象；当用户访问数据库时，从容器中获取连接对象；访问完毕将连接归还给容器。使得更节约资源，访问更高效。</p><h3 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h3><p> DataSource 是 <code>javax.sql</code> 包下操作数据库连接池的标准接口，其提供统一的获取和释放数据库连接池的操作。</p><ul><li><code>getConnection()</code>：获取连接</li><li><code>Connecion.close()</code>：归还至连接池</li></ul><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><p>C3P0 是 Apache 一个开源的 JDBC 连接池，它实现了 DataSource 和 JNDI 绑定，支持 JDBC3 规范和 JDBC2 的标准扩展。 目前使用它的开源项目有Hibernate，Spring等。<br>使用步骤：</p><ol><li>导入jar包（2个）<code>c3p0-0.9.5.2.jar</code> 及其依赖包 <code>mchange-commons-java-0.2.12.jar</code></li><li>导入数据库驱动 jar 包</li><li>定义配置文件：<br> 名称：<code>c3p0.properties</code>/<code>c3p0-config.xml</code><br> 路径：直接放在 <code>src</code> 目录下</li><li>创建核心数据库连接对象 <code>ComboPooledDateSource</code></li><li>获取连接：getConnection()</li></ol><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p>Druid是一个阿里巴巴提供的JDBC组件库，Druid是一个JDBC组件库，包括数据库连接池、SQL Parser等组件。 DruidDataSource 高效可管理的数据库连接池。<br><a href="https://github.com/alibaba/druid" target="_blank" rel="noopener">https://github.com/alibaba/druid</a><br>使用步骤：</p><ol><li>导入 jar 包 druid-1.0.9.jar</li><li>定义配置文件：<code>任意名字.properties</code>放在任意目录下</li><li>加载配置文件</li><li>获取数据库连接池对象 <code>DruidDataSourceFactory</code></li><li>获取连接：getConnection()</li></ol><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><p>Spring 框架对JDBC的简单封装，提供了一个 JdbcTemplate 对象简化JDBC的开发<br>使用步骤：</p><ol><li>导入jar包</li><li>创建 JdbcTemplate 对象，依赖于数据源 Datasource<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(ds);</span><br></pre></td></tr></table></figure></li><li>调用 JdbcTemplate 方法来完成 CRUD 的操作</li></ol><ul><li>update()：执行 DML 增删改语句</li><li>queryForMap()：查询结果并将结果集封装为 Map 集合，将列名作为 key ，将值作为 value ，将这条记录封装为一个 Map 集合。注意这个方法查询的结果集长度为 1</li><li>queryForList()：查询结果并将结果集封装到 List 集合中，其中每一条记录封装为 Map 集合，再将 Map 装在到 List</li><li>query(参数)：查询结果并将结果封装为 JavaBean 对象<br>  参数：接口 RowMapper、实现类 BeanPropertyRowMapper(可以实现数据到 JavaBean 的自动封装)  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BeanPropertyRowMapper&lt;类型&gt;(类型<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>queryForObject()：查询结果并将结果封装为对象，一般用于聚合函数的查询</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JDBC：Java DataBase Connection，简言就是使用 Java 语言操作数据库。&lt;/p&gt;
&lt;h2 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h2&gt;&lt;figure
      
    
    </summary>
    
    
      <category term="DataBase" scheme="https://hashcode.cn/categories/DataBase/"/>
    
    
      <category term="Java" scheme="https://hashcode.cn/tags/Java/"/>
    
      <category term="JDBC" scheme="https://hashcode.cn/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 基本使用</title>
    <link href="https://hashcode.cn/2019/05/09/mysql/"/>
    <id>https://hashcode.cn/2019/05/09/mysql/</id>
    <published>2019-05-09T02:01:47.000Z</published>
    <updated>2021-08-23T14:38:01.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a>SQL的分类</h2><h3 id="DDL-Data-Definition-Language"><a href="#DDL-Data-Definition-Language" class="headerlink" title="DDL(Data Definition Language)"></a>DDL(Data Definition Language)</h3><p>数据定义语言，用来定义数据库对象：数据库，表，列等。关键字：create，drop，alter 等</p><h3 id="DML-Data-Manipulation-Language"><a href="#DML-Data-Manipulation-Language" class="headerlink" title="DML(Data Manipulation Language)"></a>DML(Data Manipulation Language)</h3><p>数据操作语言，用来对数据库表中的数据进行增删改。关键字：insert，delete，update 等</p><h3 id="DQL-Data-Query-Language"><a href="#DQL-Data-Query-Language" class="headerlink" title="DQL(Data Query Language)"></a>DQL(Data Query Language)</h3><p>数据查询语言，用来查询数据库表中的记录（数据）。关键字：select，where 等</p><h3 id="DCL-Data-Control-Language"><a href="#DCL-Data-Control-Language" class="headerlink" title="DCL(Data Control Language)"></a>DCL(Data Control Language)</h3><p>用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT，REVOKE 等</p><h2 id="DDL-操作数据库-CRUD"><a href="#DDL-操作数据库-CRUD" class="headerlink" title="DDL 操作数据库(CRUD)"></a>DDL 操作数据库(CRUD)</h2><h3 id="C-Create"><a href="#C-Create" class="headerlink" title="C(Create)"></a>C(Create)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database dbname;</span><br><span class="line">create database if not exist dbname;</span><br><span class="line">create database dbname character set utf8;</span><br><span class="line">create database if not exist dbname character set utf8;</span><br></pre></td></tr></table></figure><h3 id="R-Retrieve"><a href="#R-Retrieve" class="headerlink" title="R(Retrieve)"></a>R(Retrieve)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询所有数据库的名称</span><br><span class="line">show databases;</span><br><span class="line">-- 查询某个数据库的字符集&#x2F;创建语句</span><br><span class="line">show crate database dbname;</span><br></pre></td></tr></table></figure><h3 id="U-Update"><a href="#U-Update" class="headerlink" title="U(Update)"></a>U(Update)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database dbname character set utf8;</span><br></pre></td></tr></table></figure><h3 id="D-Delete"><a href="#D-Delete" class="headerlink" title="D(Delete)"></a>D(Delete)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database dbname;</span><br><span class="line">drop database if  exist dbname;</span><br></pre></td></tr></table></figure><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询当前正在使用的数据库</span><br><span class="line">select database();</span><br><span class="line">-- 使用指定的数据库</span><br><span class="line">use dbname;</span><br></pre></td></tr></table></figure><h2 id="DML-操作表"><a href="#DML-操作表" class="headerlink" title="DML 操作表"></a>DML 操作表</h2><h3 id="C-Create-1"><a href="#C-Create-1" class="headerlink" title="C(Create)"></a>C(Create)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tbname(</span><br><span class="line">    列名1 数据类型1，</span><br><span class="line">    列名2 数据类型2，</span><br><span class="line">    ...</span><br><span class="line">    列名n 数据类型n</span><br><span class="line">);</span><br><span class="line">-- 赋值一张表</span><br><span class="line">create table 表名 like 被复制的表名;</span><br></pre></td></tr></table></figure><ul><li>数据类型：</li></ul><ol><li><code>int</code>:整数类型<ul><li>age int</li></ul></li><li><code>double</code>:小数类型<ul><li>score double(5,2)</li></ul></li><li><code>date</code>:日期，只包含年月日，yyyy-MM-dd</li><li><code>datetime</code>:日期，年月日时分秒 yyyy-MM-dd HH:mm:ss</li><li><code>timestamp</code>:时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss（如果将来不给这个字段赋值，或者赋值为Null，则默认使用当前的系统时间来自动赋值）</li><li><code>varchar</code>:字符串类型<ul><li>name varchar(20):姓名最多20个字符</li><li>zhangsan 8个字符，张三 2个字符</li></ul></li></ol><h3 id="R-Retrieve-1"><a href="#R-Retrieve-1" class="headerlink" title="R(Retrieve)"></a>R(Retrieve)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询数据库中所有表名称</span><br><span class="line">show tables;</span><br><span class="line">-- 查询表结构</span><br><span class="line">desc tbname;</span><br></pre></td></tr></table></figure><h3 id="U-Update-1"><a href="#U-Update-1" class="headerlink" title="U(Update)"></a>U(Update)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 修改表名</span><br><span class="line">alter table tbname rename to newtbname;</span><br><span class="line">-- 查看表的字符集</span><br><span class="line">show create table tbname;</span><br><span class="line">-- 修改表的字符集</span><br><span class="line">alter table tbname character set utf8;</span><br><span class="line">-- 添加一列</span><br><span class="line">alter table tbname add column_name varchar(10);</span><br><span class="line">-- 修改列名称、数据类型</span><br><span class="line">alter table tbname change gender sex varchar(20);</span><br><span class="line">-- 只修列的数据类型</span><br><span class="line">alter table tbname modify sex varchar(10);</span><br><span class="line">-- 删除列</span><br><span class="line">alter table tbname drop column_name;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">### D(Delete)</span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line">drop table tbname;</span><br><span class="line">drop table if exists tbname;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">## DML 操作表</span><br><span class="line">### 添加数据</span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line">insert into tbname(列名1,...列名n) values(值1,...值n);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>列名要和值名一一对应，如果表名后不指定列名，则默认给所有列添加值。</li><li>insert into tbname values(值1,…值n);</li><li>值除了数字以外，其他都需要用引号（单双都可以）引起来</li></ol><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from tbname [where condition];</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果不加条件，则删除表中所有的记录</li><li>如果要删除所有记录<ol><li>delete from tbname; – 不推荐使用，因为有多少条记录就会执行多少次删除操作</li><li>truncate table tbname; – 推荐使用，先删除表，在创建一张一样的空表；效率更高</li></ol></li></ul><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update tbname set 列名1 &#x3D; 值1,列名2 &#x3D; 值2,...[where condition];</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果不加任何条件，则会将表中所有记录全部修改。</p><h2 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL 查询语句"></a>DQL 查询语句</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbname;</span><br></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul><li>语法：<code>order by 子句;</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order by 排序子句1 排序方式1,...排序子句2 排序方式n;</span><br></pre></td></tr></table></figure></li><li>排序方式<br>  <code>ASC</code>：升序，默认的。<br>  <code>DESC</code>：降序。</li></ul><p><strong>注意</strong>：如果有多个排序条件，则当前面的条件值一样时候，才会判断第二条件，以此类推。</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体，进行纵向的计算。</p><ol><li><p>count：计算个数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(id) from tbname;</span><br></pre></td></tr></table></figure><ul><li>一般选择非空的列：主键</li><li>count(*) – 不建议使用</li></ul></li><li><p>max：计算最大值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select max(列名) from tbname;</span><br></pre></td></tr></table></figure></li><li><p>min：计算最小值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select min(列名) from tbname;</span><br></pre></td></tr></table></figure></li><li><p>sum：计算和</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sum(列名) from tbname;</span><br></pre></td></tr></table></figure></li><li><p>avg：计算平均值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select avg(列名) from tbname;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：聚合函数的计算，排除null值<br><strong>解决方案</strong>：</p><ol><li>选择不包含空的列进行计算</li><li><code>IFNULL</code>函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(IFNULL(列名,0)) from tbname;</span><br></pre></td></tr></table></figure></li></ol><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li>语法：<code>group by 分组字段</code></li></ul><p><strong>注意</strong>：</p><ul><li><p>分组之后查询的字段：分组字段，聚合函数</p></li><li><p><code>where</code> 和 <code>having</code> 的区别</p></li></ul><ol><li><code>where</code> 在分组之前进行限定，如果不满足条件，则不参与分组。</li><li><code>having</code> 在分组之后进行限定，如果不满足结果，则不会被查询出来</li><li><code>where</code> 后可以跟聚合函数，<code>having</code> 可以进行聚合函数的判断</li></ol><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ol><li>语法：<code>limit 开始索引,每页查询条数;</code></li><li>公式：开始的索引 = （当前的页码 - 1）* 每页显示的条数<br>eg：– 每页显示三条记录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TBNAME LIMIT 0,3; -- 第1页</span><br><span class="line">SELECT * FROM TBNAME LIMIT 3,3; -- 第2页</span><br><span class="line">SELECT * FROM TBNAME LIMIT 6,3; -- 第3页</span><br></pre></td></tr></table></figure></li><li><code>limit</code>是一个mysql的「方言」</li></ol><h2 id="DQL-查询表中的语句"><a href="#DQL-查询表中的语句" class="headerlink" title="DQL 查询表中的语句"></a>DQL 查询表中的语句</h2><ul><li>select * from tbname;</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">    字段列表</span><br><span class="line">from </span><br><span class="line">    表名列表</span><br><span class="line">where </span><br><span class="line">    条件列表</span><br><span class="line">group by </span><br><span class="line">    分组字段</span><br><span class="line">having</span><br><span class="line">    分组之后的条件</span><br><span class="line">order by </span><br><span class="line">    排序子句列表</span><br><span class="line">limit</span><br><span class="line">    分页限定</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ol><li>多个字段的查询<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 字段名1,...字段名n from tbname;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：如果查询所有字段，则可以用*来代替字段列表<br>2. 去除重复：<code>distinct</code><br>3. 多列的值计算</p><ul><li>一般可以使用四则运算计算一些列的值。</li><li><code>ifnull(表达式1,表达式2)</code>：null参与的运算，计算结果都为null<br>  表达式1:那个字段需要判断是否为Null<br>  表达式2：如果该字段为Null后的替换值</li></ul><ol start="4"><li>别名：<code>as</code>，也可以省略用空格替代。</li></ol><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ol><li>where子句后跟条件</li><li>运算符<br><code>&gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt;</code><br><code>BETWEEN...AND...</code><br><code>IN(集合)</code>、<code>NOT IN(集合)</code><br><code>IS NULL</code> 、<code>IS NOT NULL</code><br><code>AND / &amp;&amp;</code><br><code>OR / ||</code><br><code>NOT / !</code><br><code>LIKE</code>：模糊查询。占位符有：<code>_</code>表示单个任意字符，<code>%</code>表示多个任意字符。</li></ol><ul><li>用法示例:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询年龄大于20岁</span><br><span class="line">SELECT  * FROM tbname WHERE age &gt; 20;</span><br><span class="line">SELECT  * FROM tbname WHERE age &gt;&#x3D; 20;</span><br><span class="line">-- 查询年龄等于20岁</span><br><span class="line">SELECT  * FROM tbname WHERE age &#x3D; 20;</span><br><span class="line">-- 查询年龄不等于20岁</span><br><span class="line">SELECT  * FROM tbname WHERE age !&#x3D; 20;</span><br><span class="line">SELECT  * FROM tbname WHERE age &lt;&gt; 20;</span><br><span class="line">-- 查询年龄大于等于20，小于等于30</span><br><span class="line">SELECT  * FROM tbname WHERE age &gt;&#x3D; 20 &amp;&amp; age &lt;&#x3D; 30;</span><br><span class="line">SELECT  * FROM tbname WHERE age &gt;&#x3D; 20 AND age &lt;&#x3D; 30;</span><br><span class="line">SELECT  * FROM tbname WHERE BETEEN 20 AND 30;</span><br><span class="line"></span><br><span class="line">-- 查询年龄为18，20，30岁的人</span><br><span class="line">SELECT  * FROM tbname WHERE age &#x3D; 18 || age &#x3D; 20 || age &#x3D; 30;</span><br><span class="line">SELECT  * FROM tbname WHERE age &#x3D; 18 OR age &#x3D; 20 OR age &#x3D; 30;</span><br><span class="line">SELECT  * FROM tbname WHERE age IN (18,20,30);</span><br><span class="line">-- 查询年龄不为18，20，30岁的人</span><br><span class="line">SELECT  * FROM tbname WHERE age NOT IN (18,20,30);</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩为null</span><br><span class="line">SELECT  * FROM tbname WHERE english IS NULL;</span><br><span class="line">-- 查询英语成绩为不null </span><br><span class="line">SELECT  * FROM tbname WHERE english IS NOT NULL;</span><br><span class="line"></span><br><span class="line">-- 查询姓马的人</span><br><span class="line">SELECT * FROM tbname WHERE name LIKE &quot;马%&quot;;</span><br><span class="line">-- 查询姓名中第二个字为化的人</span><br><span class="line">SELECT * FROM tbname WHERE name LIKE &quot;_化%&quot;;</span><br><span class="line">-- 查询姓名中包含化的人</span><br><span class="line">SELECT * FROM tbname WHERE name LIKE &quot;%化%&quot;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li><p>内连接<br>  显式内连接：</p><pre><code>select 字段列表 from 表名1 inner join 表名2 on 条件</code></pre><p>  隐式内连接：</p><pre><code>使用 where 条件消除无用数据</code></pre></li><li><p>外链接<br>  左外连接：</p><pre><code>select 字段列表 from 表1 left [outer] join 表2 on 条件;(查询的是左表所有字段以及其交集部分)</code></pre><p>  右外链接</p><pre><code>select 字段列表 from 表1 right [outer] join 表2 on 条件;(查询的是右表所有字段以及其交集部分)</code></pre></li><li><p>子查询</p></li></ul><p><strong>概念</strong>：查询中嵌套查询，成嵌套查询为子查询。</p><ol><li>子查询的结果是<code>单行单列</code><br> 子查询可以作为条件，使用运算符去判断。运算符：<code>&gt; / &gt;= / &lt; / &lt;= / =</code><br> eg： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp where emp.salary &lt; (select avg(salary) from emp);</span><br></pre></td></tr></table></figure></li><li>子查询的结果是<code>多行单列</code><br> 子查询可以作为条件，使用运算符 <code>IN</code> 去判断<br> eg： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp where dept_id in (select id from dept where name in(&#39;财务部&#39;,&#39;市场部&#39;));</span><br></pre></td></tr></table></figure></li><li>子查询的结果是<code>多行多列</code><br> 子查询可以作为一张虚拟表参与查询<br> eg： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from dept t1,(select  * from emp where emp.&#96;join_date&#96; &gt; &#39;2011-11-11&#39;) t2</span><br><span class="line">where t1.id &#x3D; t2.dept_id;</span><br></pre></td></tr></table></figure></li></ol><h2 id="约束-Constriant"><a href="#约束-Constriant" class="headerlink" title="约束(Constriant)"></a>约束(Constriant)</h2><p>对表中的数据进行限定，保证数据的正确性，完整性和有效性。</p><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p><code>not null</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 1. 创建表时添加约束</span><br><span class="line">create table tbname(</span><br><span class="line">    id int;</span><br><span class="line">    name varchar(20) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 2. 删除name的非空约束</span><br><span class="line">alter table tbname modify name varchar(20);</span><br><span class="line"></span><br><span class="line">-- 3. 创建完表后，添加非空约束</span><br><span class="line">alter table tbname modify name varchar(20) not null;</span><br></pre></td></tr></table></figure><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p><code>unique</code>,值不能重复</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1. 创建表时，添加唯一约束</span><br><span class="line">create table tbname(</span><br><span class="line">    id int.</span><br><span class="line">    phone_number varchar(20) unique</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 2.删除唯一约束</span><br><span class="line">-- 错误写法 drop table tbname modify phone_number varchar(20);</span><br><span class="line">alter table tbname drop index phone_number;</span><br><span class="line"></span><br><span class="line">-- 3. 创建表之后添加唯一约束</span><br><span class="line">alter table tbname modify phone_number varchar(20);</span><br></pre></td></tr></table></figure><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p><code>primary key</code>，非空而且唯一，一张表只能有一个主键字段，唯一标识。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1. 创建表时，添加主键约束</span><br><span class="line">create table tbname(</span><br><span class="line">    id int primary key,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 2. 删除主键约束</span><br><span class="line">-- 错误写法：alter table tbname modify id int;</span><br><span class="line">alter table tbname drop primary key;</span><br><span class="line"></span><br><span class="line">-- 3. 创建完表后，添加主键约束</span><br><span class="line">alter table tbname modify id int primary key;</span><br></pre></td></tr></table></figure><h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><p><code>auto_increment</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1. 创建表时添加主键并且指定为自增长</span><br><span class="line">create table tbname(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br><span class="line">-- 2. 删除自增长</span><br><span class="line">alter table tbname modify id int;</span><br><span class="line">-- 3. 创建完表后添加自增长</span><br><span class="line">alter table tbname modify id int auto_increment;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一般情况下<code>auto_increment</code> 与<code>primary key</code> 搭配使用，但是它也是可以单独使用的。</p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p><code>foreign key</code>，让表与表产生关系，从而保证数据的正确性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1. 在创建表时，可以添加外键。</span><br><span class="line"></span><br><span class="line">create table tbname(</span><br><span class="line">    .....</span><br><span class="line">    外键列</span><br><span class="line">    constriant 外键名称 foreign key(外键列名称) references 主表名称(主表列名称)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 2. 删除外键</span><br><span class="line">alter table tbname drop foreign key 外键名称;</span><br><span class="line"></span><br><span class="line">-- 3. 创建完表之后，添加外键</span><br><span class="line">alter table tbname add constraint 外键名称 foreign key(外键列名) references 主表名称(主表列名);</span><br></pre></td></tr></table></figure><h3 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h3><p>在操作相关联的表的数据时候，会同步更新或者删除</p><ol><li>添加级联<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table tbname add constraint 外键名称 foreign key(外键列名) references 主表名称(主表列名) on update cascade on delete cascade;</span><br></pre></td></tr></table></figure></li><li>分类<br> 级联更新：<code>on update cascade</code><br> 级联删除：<code>on delete cascade</code></li></ol><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><h3 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h3><ul><li>一对一 &lt;1:1&gt;<pre><code>eg：人和身份证</code></pre>实现方式：一对一关系的实现，可以在任意一方添加唯一外键指向另一方的外键。一般还是建议合并为一张表。</li><li>一对多（多对一）&lt;1:n/n:1&gt;<pre><code>eg：部门和员工</code></pre>实现方式：在多的一方建立外键，指向一的一方的主键。</li><li>多对多 &lt;m:n&gt;<pre><code>eg：学生和课程</code></pre>实现方式：多对多关系实现需要借助第三章中间表，中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。也可以使用联合主键。</li></ul><h3 id="数据库设计的范式"><a href="#数据库设计的范式" class="headerlink" title="数据库设计的范式"></a>数据库设计的范式</h3><ul><li>第一范式（1NF）：每一列都是不可分割的原子数据项。</li><li>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF的基础上非主属性对主码的部分函数依赖）</li></ul><ol><li><code>函数依赖</code>：A–&gt;B，如果A属性（属性组）的值，可以确定唯一的B属性的值，则称B依赖于A。<pre><code>eg：学号--&gt;姓名。（学号，课程名称）--&gt;分数</code></pre></li><li><code>完全函数依赖</code>：A–&gt;B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。<pre><code>eg：（学号，课程名称）--&gt;分数</code></pre></li><li><code>部分函数依赖</code>：A–&gt;B，如果A是一个属性组，则B属性值的确定只需要依赖A属性组中某一些值即可。<pre><code>eg：（学号，课程名称）--&gt;姓名</code></pre></li><li><code>传递函数依赖</code>：A–&gt;B，B–&gt;C；如果A属性（属性组），可以唯一确定B属性的值；B属性（属性组）的值可以唯一确定C属性的值，则称C传递函数依赖于A<pre><code>eg：学号--&gt;系名，系名-&gt;系主任</code></pre></li><li><code>码</code>：如果在一张表中，一个属性或者属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码<br> <code>主属性</code>：码属性组中的所有属性<br> <code>非主属性</code>：除过码属性组的所有属性</li></ol><ul><li>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其他非主属性（在2NF基础上消除传递依赖）</li></ul><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; mysqldump -u用户名 -p密码 &gt; 保存的路径</span><br></pre></td></tr></table></figure><h3 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h3><ol><li>登录数据库 mysql -uroot -proot </li><li>创建数据库 create database dbname</li><li>使用数据库 use dbname</li><li>执行以下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; source 文件路径</span><br></pre></td></tr></table></figure></li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的基本介绍"><a href="#事务的基本介绍" class="headerlink" title="事务的基本介绍"></a>事务的基本介绍</h3><ul><li>概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</li><li>操作：</li></ul><ol><li>开启事务：<code>start transaction;</code></li><li>回滚：<code>rollback;</code></li><li>提交：<code>commit;</code></li><li>事务的两种提交方式<br> 自动：MySQL 就是自动提交的，一条DML（增删改）语句会自动提交一次事务。<br> 手动：Oracle 数据库默认手动提交事务。需要先开启事务再提交。<br> 修改事务的提交方式：<pre><code>select @@autocommit;-- 1代表自动，0代表手动set @@autocommit = 0;</code></pre></li></ol><h3 id="事务的四大基本特征"><a href="#事务的四大基本特征" class="headerlink" title="事务的四大基本特征"></a>事务的四大基本特征</h3><ol><li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</li><li>持久性：当事务提交或回滚后，数据库会持久化的保存数据。</li><li>隔离性：多个事务之间，相互独立。</li><li>一致性：事务操作前后，数据总量不变。</li></ol><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>概念<br>多个事务之间是独立的，相互隔离的；但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</li><li>存在问题</li></ul><ol><li>脏读：一个事务，读取到另外一个事务中没有提交的数据。</li><li>不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样。</li><li>幻读：一个事务操作（DML）数据表中所有事物，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li></ol><ul><li>隔离级别</li></ul><ol><li><code>read uncommitted</code>：读未提交；产生的问题：脏读、不可重复读、幻读</li><li><code>read committed</code>：读已提交（Oracle 默认）；产生的问题：不可重复读、幻读</li><li><code>repeatable read</code>：可重复读（MySQL 默认）；产生的问题：幻读</li><li><code>serializable</code>：串行化；可以解决所有问题</li></ol><p><strong>注意</strong>：隔离级别从小到大，安全性越来越高，但是效率越来越低。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">-- 设置隔离级别</span><br><span class="line">set global transaction isolation level 级别字符串;</span><br></pre></td></tr></table></figure><h2 id="DCL-管理、授权用户"><a href="#DCL-管理、授权用户" class="headerlink" title="DCL 管理、授权用户"></a>DCL 管理、授权用户</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ol><li>添加用户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</span><br></pre></td></tr></table></figure></li><li>删除用户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop user &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure></li><li>修改用户密码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set password  &#x3D; password(&#39;新密码&#39;) where user &#x3D; &#39;用户名&#39;;</span><br><span class="line">set password for &#39;用户名&#39;@&#39;主机名&#39; &#x3D; password(&#39;新密码&#39;);</span><br></pre></td></tr></table></figure></li><li>查询用户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 切换到mysql数据库</span><br><span class="line">use mysql;</span><br><span class="line">-- 查询user表</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：通配符<code>%</code>表示可以在任意主机使用该用户登录数据库</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ol><li>查询权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show grant for &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure></li><li>授予权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</span><br><span class="line"></span><br><span class="line">-- 给张三用户授予所有权限，在任意数据库任意表上。</span><br><span class="line">eg:grant all on *.* to &#39;zhangsan&#39;@&#39;localhost&#39;;</span><br></pre></td></tr></table></figure></li><li>撤销权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="修改-mysql-设置"><a href="#修改-mysql-设置" class="headerlink" title="修改 mysql 设置"></a>修改 mysql 设置</h2><h3 id="更改默认编码"><a href="#更改默认编码" class="headerlink" title="更改默认编码"></a>更改默认编码</h3><p>查看 mysql 数据库的默认编码命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variable like <span class="string">'character%'</span>;</span><br><span class="line"></span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">| Variable_name            | Value                                                  |</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">| character_set_client     | utf8                                                   |</span><br><span class="line">| character_set_connection | utf8                                                   |</span><br><span class="line">| character_set_database   | latin1                                                 |</span><br><span class="line">| character_set_filesystem | binary                                                 |</span><br><span class="line">| character_set_results    | utf8                                                   |</span><br><span class="line">| character_set_server     | latin1                                                 |</span><br><span class="line">| character_set_system     | utf8                                                   |</span><br><span class="line">| character_sets_dir       | /usr/<span class="built_in">local</span>/mysql-5.7.10-osx10.9-x86_64/share/charsets/ |</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure><p>可见 database 和 server 的字符集使用了 <code>latin1</code> 编码方式，不支持中文，即存储中文时会出现乱码。以下修改方法：</p><ol><li>cd /private/etc/</li><li>新增一个 my.cnf 文件</li><li>然后写入以下命令保存退出<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line">collation-server = utf8_unicode_ci</span><br><span class="line">init-connect=<span class="string">'SET NAMES utf8'</span></span><br></pre></td></tr></table></figure></li><li>重启 mysql</li></ol><h3 id="忘记root用户密码"><a href="#忘记root用户密码" class="headerlink" title="忘记root用户密码"></a>忘记root用户密码</h3><ol><li>net stop mysql</li><li>mysqld –skip-grant-tables(使用无验证服务启动mysql服务)</li><li>打开新的终端窗口，直接输入 <code>mysql</code> 命令</li><li>use mysql;</li><li>update user set password = password(‘新密码’) where user = ‘root’;</li><li>关闭两个窗口，并结束 <code>mysqld</code> 进程</li><li>启动 <code>mysql</code> 服务</li><li>使用新密码登录</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SQL的分类&quot;&gt;&lt;a href=&quot;#SQL的分类&quot; class=&quot;headerlink&quot; title=&quot;SQL的分类&quot;&gt;&lt;/a&gt;SQL的分类&lt;/h2&gt;&lt;h3 id=&quot;DDL-Data-Definition-Language&quot;&gt;&lt;a href=&quot;#DDL-Data-
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hashcode.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://hashcode.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>写在百年五四</title>
    <link href="https://hashcode.cn/2019/05/04/daily-2019-0504/"/>
    <id>https://hashcode.cn/2019/05/04/daily-2019-0504/</id>
    <published>2019-05-04T11:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.796Z</updated>
    
    <content type="html"><![CDATA[<p>最近读完了《奇特的一生》<br><img src="/images/read/read_qtdys.jpg" alt=""></p><hr><p>开始觉得如果在未来的某个时刻，能够清晰的回忆起某一天的某件事以及当时自己是怎样的心情。就会让岁月的流逝变得更有意义，所以决定按天来记录自己的日常琐事；虽是流水账的形式呈现，但却可以让自己想起那些细节中包含的丰富故事。倘若没有文字的记录，那么便无法清晰唤起这些记忆中的细节。于是我决定以这种流水账的形式来记录未来读研岁月的每一天，也许其间会有中断，但我想养成这样的习惯一定是一件分外美好的事。</p><p>自律给我自由，这是KEEP的一句slogan。知乎上曾有一个问答是：「有哪些习惯值得长期坚持？」其中一个高票回答大意是：读书+跑步+学习英语。</p><p>俗话说：读书破万卷，下笔如有神。如果要让每一天的经历或者感悟，抑或某一刻的情感更自然流淌，并以流利的文字来呈现；就是要养成一个每天阅读的习惯，无论是电子书，纸质书。功利一点的做法就是：要固定自己每天阅读时间，每个月能读几本书，每年的阅读计划有多少。我想这样在年底对自己这一年做回顾总结的时候。就读书这件事来说，应是会有很大的收获的。</p><p>我也始终认为，一个人如果不能自己的身材进行较好的控制和管理，那么他将可能一事无成。所以未来三年，我要坚持跑步和游泳的习惯，有每周的目标和年度的量化，最好是能做到风雨无阻。</p><p>央视曾经有采访一个大佬视频，具体是谁记得已经不是特别清楚，谈到自己年轻的时候对于英语的学习不屑一顾，觉得没有这个东西自己的也会生活的很好。但是多年以后，再次谈起这件事，他一改曾经的认识，认为英文的学习会为自己的人生增添一扇窗户，是与世界沟通的一种工具。如果拥有了这一扇窗，自己的生命可能就会是另外一种维度。那么，坚持学习英文吧。为了让自己的生命更丰富，也为了更了解这个世界，因为生命只有一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近读完了《奇特的一生》&lt;br&gt;&lt;img src=&quot;/images/read/read_qtdys.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;开始觉得如果在未来的某个时刻，能够清晰的回忆起某一天的某件事以及当时自己是怎样的心情。就会让岁月的流逝变得更有意义，所以决定
      
    
    </summary>
    
    
      <category term="Daily" scheme="https://hashcode.cn/categories/Daily/"/>
    
    
      <category term="Daily" scheme="https://hashcode.cn/tags/Daily/"/>
    
      <category term="Readed" scheme="https://hashcode.cn/tags/Readed/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 使用技巧(一)</title>
    <link href="https://hashcode.cn/2019/05/04/vscode-note-01/"/>
    <id>https://hashcode.cn/2019/05/04/vscode-note-01/</id>
    <published>2019-05-04T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VS-Code-Note-01"><a href="#VS-Code-Note-01" class="headerlink" title="VS Code Note 01"></a>VS Code Note 01</h1><h2 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h2><p><code>Cmd+Shift+P / F1</code>：打开命令面板，是VS Code的主要交互界面</p><h2 id="界面概览"><a href="#界面概览" class="headerlink" title="界面概览"></a>界面概览</h2><p>文件资源管理器：<code>Ctrl+Shift+E</code><br>跨文件搜索：<code>Ctrl+Shift+F</code><br>源代码管理：<code>Ctrl+Shift+G</code><br>启动和调试：<code>Ctrl+Shift+D</code><br>管理扩展：<code>Ctrl+Shift+X</code><br>查看错误和警告：<code>Ctrl+Shift+M</code><br><img src="/images/tech/vs-view-preview.png" alt="vs-view-preview"></p><h2 id="命令行的使用"><a href="#命令行的使用" class="headerlink" title="命令行的使用"></a>命令行的使用</h2><p>如果你是在 macOS 上使用，安装后打开命令面板，搜索<code>shell</code> 命令：在 PATH 中安装 <code>code</code> 命令并执行，然后重启终端模拟就可以了。<br><img src="/images/tech/vs-shell-on-terminal.png" alt="vs-shell-on-terminal"></p><h2 id="OPTIONS（常用命令）"><a href="#OPTIONS（常用命令）" class="headerlink" title="OPTIONS（常用命令）"></a>OPTIONS（常用命令）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-n --new-window                   Force to open a new window..</span><br><span class="line">-r --reuse-window  Force to open a file or folder <span class="keyword">in</span> an already opened window.</span><br><span class="line">-g --goto &lt;file:line[:character]&gt; Open a file at the path on the specified line and character.</span><br><span class="line">-d --diff &lt;file&gt; &lt;file&gt;           Compare two files with each other.</span><br></pre></td></tr></table></figure><h3 id="通过命令行打开文件，并滚动至特定的行"><a href="#通过命令行打开文件，并滚动至特定的行" class="headerlink" title="通过命令行打开文件，并滚动至特定的行"></a>通过命令行打开文件，并滚动至特定的<code>行</code></h3><p>比如输入<code>code -r -g package.json:128</code>命令，你就可以打开 package.json 这个文件，然后自动跳转到 128 行。适用于某文件错误的行数的快速定位</p><h3 id="比较两个文件的内容"><a href="#比较两个文件的内容" class="headerlink" title="比较两个文件的内容"></a>比较两个文件的内容</h3><p>只需使用 <code>-d</code>参数，并传入两个文件路径，比如输入 <code>code -r -d a.txt b.txt</code>命令</p><h3 id="打开管道内容"><a href="#打开管道内容" class="headerlink" title="打开管道内容"></a>打开管道内容</h3><p>将命令行 ls 的执行结果在 VS Code 的编辑器中打开 <code>ls | code -</code><br>注：<a href="https://zh.wikipedia.org/zh-hans/%E7%AE%A1%E9%81%93_(Unix" target="_blank" rel="noopener">管道的说明</a></p><h3 id="如何在终端和文件之间快速切换"><a href="#如何在终端和文件之间快速切换" class="headerlink" title="如何在终端和文件之间快速切换"></a>如何在终端和文件之间快速切换</h3><p>快捷键：Ctrl + `</p><h1 id="VS-Code-Note-02"><a href="#VS-Code-Note-02" class="headerlink" title="VS Code Note 02"></a>VS Code Note 02</h1><h2 id="光标的快捷键移动操作"><a href="#光标的快捷键移动操作" class="headerlink" title="光标的快捷键移动操作"></a>光标的快捷键移动操作</h2><ol><li>首先是针对单词的光标移动: <code>Option + 左右方向键</code> 同时按住 Option 和方向键，那么光标移动的颗粒度就变成了单词，你就可以在文档中以单词为单位不停地移动光标了。</li><li>第二种方式是把光标移动到行首或者行末：<code>Cmd + 左右方向键</code></li><li>接下来一种是对于代码块的光标移动：<code>Cmd + Shift + \</code>，就可以在这对花括号之间跳转。</li><li>最后是移动到文档的第一行或者最后一行：<code>Cmd + 上下方向键</code></li></ol><h2 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h2><p>基于以上快捷键，只需要多按一个 Shift 键，就可以在移动光标的同时选中其中的文本。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><ol><li>删除光标右侧所有内容：<code>Cmd + fn + delete</code></li><li>删除光标左侧所有内容：<code>Cmd + delete</code></li><li>删除单词内右侧的字符：<code>Option + fn + delete</code></li><li>删除单词内左侧的字符：<code>Option + delete</code> </li></ol><h2 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h2><p>首先你可以打开命令面板（<code>Cmd + Shift + p</code>），搜索“打开键盘快捷方式”然后执行，这时你将看到相对应的界面。<br><img src="/images/tech/vs-keyboard-shortcuts.png" alt="vs-keyboard-shortcuts"></p><p>比如，你可以搜索“选择括号内所有内容”，双击，按下<code>Cmd + Shift + ]</code>，然后按下回车，这个快捷键就绑定上了。<br>比如，你通过搜索 “cmd+backspace”这组快捷键，发现它对应的命令是“删除左侧所有内容”，但你不希望使用这个命令，那你就可以通过右键选择删除该快捷键的绑定。</p><h1 id="VS-Code-Note-03"><a href="#VS-Code-Note-03" class="headerlink" title="VS Code Note 03"></a>VS Code Note 03</h1><h2 id="代码行编辑"><a href="#代码行编辑" class="headerlink" title="代码行编辑"></a>代码行编辑</h2><ol><li>删除当前行代码： <code>Cmd + Shift + K</code></li><li>剪切当前行代码： <code>Cmd + x</code></li><li>在当前代码上面开始一行时：<code>Cmd + Shift + Enter</code></li><li>在当前代码下面开始一行时：<code>Cmd + Enter</code></li><li>移动当前选中行代码：<code>Option + 上下方向键</code></li><li>赋值当前选中行代码：<code>Option + Shift + 上下方向键</code></li></ol><h2 id="编程语言相关的命令"><a href="#编程语言相关的命令" class="headerlink" title="编程语言相关的命令"></a>编程语言相关的命令</h2><ol><li>添加注释：<code>Cmd + /</code></li><li>代码格式化：<code>Option + Shift + F</code>，VS Code 也会根据你当前的语言，选择相关的插件。当然，前提条件是你已经安装了相关插件。</li><li>选中的代码格式化：<code>Cmd + k</code> or <code>Cmd + F</code>，这样只有这段被选中的代码才会被格式化。</li></ol><h2 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h2><ol><li>调换字符的位置：<code>Ctrl + t</code></li><li>是调整字符的大小写：你可以选中一串字符，然后在命令面板里运行“转换为大写(transform to uppercase)”或 “转换为小写”, 来变换字符的大小写。</li><li>是合并代码行：<code>Ctrl + j</code>，可以把较短的代码合并至一行，而不需要不断地调整光标、删除换行符。</li><li>是撤销光标的移动和选择：<code>Cmd + U</code></li></ol><h1 id="VS-Code-Note-04"><a href="#VS-Code-Note-04" class="headerlink" title="VS Code Note 04"></a>VS Code Note 04</h1><h2 id="创建多个光标"><a href="#创建多个光标" class="headerlink" title="创建多个光标"></a>创建多个光标</h2><h3 id="两个特别命令"><a href="#两个特别命令" class="headerlink" title="两个特别命令"></a>两个特别命令</h3><ol><li><code>Cmd + D</code> 适用情况比较特别：处理多次出现的“相同”单词。如果要处理的文本并不是相同的，那么这个方法就不适用了。</li><li><code>Option + Shift + i</code> 首先选择多行代码，然后按下 “Option + Shift + i” ,这样操作的结果是：每一行的最后都会创建一个新的光标。</li></ol><h2 id="快捷键跳转"><a href="#快捷键跳转" class="headerlink" title="快捷键跳转"></a>快捷键跳转</h2><h3 id="多文件跳转"><a href="#多文件跳转" class="headerlink" title="多文件跳转"></a>多文件跳转</h3><ol><li><code>Ctrl + Tab</code> 在正在操作的文件列表中切换文件</li><li><code>Cmd + P</code> 打开最近的文件列表，并支持搜索功能<br>「小技巧」 <code>Cmd + Enter</code> 当找到文件后按下这个快捷键可在新窗口中打开该文件</li></ol><h3 id="行跳转"><a href="#行跳转" class="headerlink" title="行跳转"></a>行跳转</h3><p><code>Ctrl + G</code> 跳转到指定的代码行<br>「高级组合技巧」：按下<code>Cmd + P</code> 直接输入<code>文件名：行号</code> eg:<code>main.css:3</code></p><h3 id="符号跳转"><a href="#符号跳转" class="headerlink" title="符号跳转"></a>符号跳转</h3><p><code>Cmd + R</code> 能够看到当前文件里的所有符号(包括类，方法等)。</p><h3 id="定义-Definition-和实现-implementation-跳转"><a href="#定义-Definition-和实现-implementation-跳转" class="headerlink" title="定义 (Definition) 和实现 (implementation) 跳转"></a>定义 (Definition) 和实现 (implementation) 跳转</h3><p><code>Cmd + F12</code> 选中引用跳转到函数的实现位置</p><h3 id="引用-Reference-跳转"><a href="#引用-Reference-跳转" class="headerlink" title="引用 (Reference) 跳转"></a>引用 (Reference) 跳转</h3><p><code>Shift + F12</code> 选中函数或类按下这个快捷键就可以出现一个引用的列表，选择后内嵌的编辑器里便展示相应的引用代码</p><h1 id="VS-Code-Note-04-1"><a href="#VS-Code-Note-04-1" class="headerlink" title="VS Code Note 04"></a>VS Code Note 04</h1><h2 id="玩转鼠标"><a href="#玩转鼠标" class="headerlink" title="玩转鼠标"></a>玩转鼠标</h2><h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><ol><li>在VS Code中，你单击鼠标左键就可以把光标移动到相应的位置。</li><li>而双击鼠标左键，则会将当前光标下的单词选中。</li><li>连续三次按下鼠标左键，则会选中当前这一行代码。</li><li>最后是连续四次按下鼠标左键，则会选中整个文档。</li></ol><h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><p>在 VS Code中，我们除了能够使用鼠标来选择文本以外，还能够使用鼠标对文本进行一定程度的修改，我们把它称为拖放功能（drag and drop）。<br>比如在示例代码中，我们选中 bar 这个函数，然后将鼠标移到这段选中的代码之上，按下鼠标左键不松开。这时你可以看到，鼠标指针已经从一条竖线，变成了一个箭头。这时候我们移动鼠标的话，就可以把这段文本拖拽到我们想要的位置。<br><img src="/images/tech/vs-bar-drag-and-drop.gif" alt=""></p><h3 id="悬停提示窗口"><a href="#悬停提示窗口" class="headerlink" title="悬停提示窗口"></a>悬停提示窗口</h3><p>在 VS Code 的编辑器里使用鼠标的过程中，当你的鼠标移动到某些文本上之后，稍待片刻就能看到一个悬停提示窗口。这个窗口里会显示跟鼠标下文本相关的信息。</p><ul><li>方法(Method)</li></ul><p>比如，在示例代码中，当我把鼠标移动到第五行 foo 上后，悬停提示窗口里展示了 foo的类型信息，它告诉我们 foo是一个函数，不需要任何的参数，返回值是 void。<br><img src="/images/tech/vs-method-hover-window.gif" alt=""></p><p>如果我把鼠标移动到 foo 上面时，按下 Cmd 键，则能够在悬停提示窗口里直接看到 foo的实现。<br><img src="/images/tech/vs-method-hover-window-detail.gif" alt=""></p><ul><li>变量(Field)</li></ul><p>在 JavaScript 或者 Java 这样的编程语言中，当我们把鼠标移动到某个变量上时，我们能够看到这个变量的定义信息。而在 CSS 中，当我们把鼠标移动到一个 CSS 规则上时，我们能看到的则是一段能够让这个 CSS 规则生效的 HTML 的样例代码。<br><img src="/images/tech/vs-field-hover-window.gif" alt=""></p><h3 id="代码跳转和链接"><a href="#代码跳转和链接" class="headerlink" title="代码跳转和链接"></a>代码跳转和链接</h3><p>我们还是把鼠标移动到示例代码的第五行 foo 上，然后按下 Cmd 键，这时候 foo下面出现了一个下划线。然后当我们按下鼠标左键，就跳转到了 foo函数的定义处。<br><img src="/images/tech/vs-code-method-show-detail.gif" alt=""><br>当我们在编写 Markdown 这样的非编程语言的文档时，也可以通过 <code>Cmd + 鼠标左键</code> 来打开超级链接。<br><img src="/images/tech/vs-markdown-open-linked.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VS-Code-Note-01&quot;&gt;&lt;a href=&quot;#VS-Code-Note-01&quot; class=&quot;headerlink&quot; title=&quot;VS Code Note 01&quot;&gt;&lt;/a&gt;VS Code Note 01&lt;/h1&gt;&lt;h2 id=&quot;命令面板&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="VSCode" scheme="https://hashcode.cn/categories/VSCode/"/>
    
    
      <category term="VSCode" scheme="https://hashcode.cn/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Java - 泛型(Generic)</title>
    <link href="https://hashcode.cn/2019/05/01/java-generic/"/>
    <id>https://hashcode.cn/2019/05/01/java-generic/</id>
    <published>2019-05-01T02:01:47.000Z</published>
    <updated>2020-11-20T06:12:25.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型；也可以把泛型看做是一个变量，用来接收数据类型。泛型是提供给java编译器使用的，只在编译阶段可见，在源码文件编译为字节码文件的过程中，泛型会被移除掉，这个过程叫做<strong>泛型的擦除</strong>。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>E:Element元素<br>T:Type类型</p><p>ArrayList<E>中的E称为Element类型参数变量<br>ArrayList<Integer>中的Integer称为实际类型参数</p><p>整个称为ArrayList<E>泛型类型<br>整个ArrayList<Integer>称为参数化的类型ParameterizedType</p><h2 id="集合泛型"><a href="#集合泛型" class="headerlink" title="集合泛型"></a>集合泛型</h2><p>在jdk1.5以前对象一旦存入集合就丢失了类型，在获取时需要进行强转，麻烦并且容易出错。<br>在jdk1.5以后提供了泛型技术，可以在定义泛型时明确指定存储的类型；如果不指定默认为Object，可以存储任意类型数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//jdk1.7之后，后面的泛型可以说省略不写，会自动推导。</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：泛型不支持基本数据类型，但支持其包装类。</p><h2 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h2><h3 id="定义在方法上的泛型"><a href="#定义在方法上的泛型" class="headerlink" title="定义在方法上的泛型"></a>定义在方法上的泛型</h3><p>作用范围是当前方法，在方法被调用时候，编译器会自动判断出泛型的具体类型。</p><h3 id="定义在类上的泛型"><a href="#定义在类上的泛型" class="headerlink" title="定义在类上的泛型"></a>定义在类上的泛型</h3><p>作用范围是整个类，在创建类的对象时，就需要明确的指定泛型的具体类型；如果不指定默认为此泛型的上边界，如果没有上边界则默认上边界为Object。</p><ul><li>定义格式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class  类名&lt;代表泛型的变量&gt; &#123; &#125;</span><br></pre></td></tr></table></figure></li><li>例如，API中的ArrayList集合<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用格式：在使用时候在指定具体的泛型类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体为String</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"string"</span>);</span><br><span class="line"><span class="comment">//具体为Integer</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"integer"</span>);</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>： 静态方法不能使用类定义的泛形，而应单独定义泛形</p><h3 id="定义在接口上的泛型"><a href="#定义在接口上的泛型" class="headerlink" title="定义在接口上的泛型"></a>定义在接口上的泛型</h3><ul><li>定义格式：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名&lt;代表泛型的变量&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>第一种方式<br>eg：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">get</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>使用格式：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImpl</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>第二种方式，接口是什么类型，继承实现类还使用什么抽象类型。仿ArrayList<br>eg：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">I</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>使用格式：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImpl</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">I</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型的类型不确定，可以用通配符<code>&lt;?&gt;</code>表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中自身元素方法无法使用。</p><p>eg：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; list0= <span class="keyword">null</span>;</span><br><span class="line">list0=list1;<span class="comment">//报错</span></span><br><span class="line">list0=list2;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>list0 没有办法引用 list1 和 list2，这时该如何设计 list0 的泛型使他能够引用 list1 和 list2 呢?<br>此时引入泛型通配符可以写成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt; list0 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>表明当前集合泛型的具体类型是不确定的，此时这个引用就可以接受任意具体类型泛型。</p><h2 id="泛型的边界"><a href="#泛型的边界" class="headerlink" title="泛型的边界"></a>泛型的边界</h2><p>使用了泛型通配符以后，List&lt;?&gt; list0 就可以等于任意的类型了，但是有时我们还可能需要对这个引用可以接受的泛型类型进行一些限定：</p><h3 id="泛型的上限"><a href="#泛型的上限" class="headerlink" title="泛型的上限"></a>泛型的上限</h3><ul><li>格式：<code>类型名称 &lt;? extends 类&gt; 对象名称</code><br>也就是说，可以通过这种方式定义此泛型所接受的具体类型必须是限定的<code>该类型或其子类类型</code>。<br>在使用这个泛型时，可以使用这个泛型上边界所具有的方法；<br>如果不明确限定泛型的上边界，则上边界默认为Object。</li></ul><h3 id="泛型的下限"><a href="#泛型的下限" class="headerlink" title="泛型的下限"></a>泛型的下限</h3><ul><li>格式：<code>类型名称 &lt;? super 类&gt; 对象名称</code><br>也就是说，可以通过这种方式定义此泛型接受的具体类型必须是限定的<code>该类型或其父类类型</code>。</li></ul><p>eg:Integer extends Number extends Object</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;</span><br><span class="line">Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;</span><br><span class="line">Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;</span><br><span class="line">Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;</span><br><span class="line"></span><br><span class="line">getElement1(list1);</span><br><span class="line">getElement1(list2);<span class="comment">//报错</span></span><br><span class="line">getElement1(list3);</span><br><span class="line">getElement1(list3);<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">getElement2(list3);</span><br><span class="line">getElement2(list4);</span><br><span class="line"><span class="comment">//泛型的上限：此时的泛型? 必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//泛型的下限：此时的泛型? 必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型；也可以把泛型看做是一个变量，用来接收数据类型。泛型是提供给jav
      
    
    </summary>
    
    
      <category term="Java" scheme="https://hashcode.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://hashcode.cn/tags/Java/"/>
    
  </entry>
  
</feed>
